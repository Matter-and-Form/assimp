/*
Open Asset Import Library (ASSIMP)
----------------------------------------------------------------------

Copyright (c) 2006-2010, ASSIMP Development Team
All rights reserved.

Redistribution and use of this software in source and binary forms, 
with or without modification, are permitted provided that the 
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the ASSIMP team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the ASSIMP Development Team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** MACHINE-GENERATED by scripts/STEPImporter/CppGenerator.py */

//#include "AssimpPCH.h"
#ifndef ASSIMP_BUILD_NO_STEP_IMPORTER

#include "STEPReaderGen.h"

namespace Assimp {
using namespace STEP;

namespace {

	typedef EXPRESS::ConversionSchema::SchemaEntry SchemaEntry;
	const SchemaEntry schema_raw[] =  {
		SchemaEntry("absorbed_dose_measure",NULL )
,		SchemaEntry("acceleration_measure",NULL )
,		SchemaEntry("action_items",NULL )
,		SchemaEntry("action_method_items",NULL )
,		SchemaEntry("action_request_item",NULL )
,		SchemaEntry("ahead_or_behind",NULL )
,		SchemaEntry("amount_of_substance_measure",NULL )
,		SchemaEntry("angle_direction_reference_select",NULL )
,		SchemaEntry("angle_direction_reference_with_a2p3d_select",NULL )
,		SchemaEntry("angle_relator",NULL )
,		SchemaEntry("annotation_plane_element",NULL )
,		SchemaEntry("annotation_representation_select",NULL )
,		SchemaEntry("annotation_symbol_occurrence_item",NULL )
,		SchemaEntry("annotation_text_occurrence_item",NULL )
,		SchemaEntry("approval_item",NULL )
,		SchemaEntry("approved_item",NULL )
,		SchemaEntry("area_measure",NULL )
,		SchemaEntry("area_or_view",NULL )
,		SchemaEntry("attribute_classification_item",NULL )
,		SchemaEntry("attribute_language_item",NULL )
,		SchemaEntry("attribute_type",NULL )
,		SchemaEntry("axis2_placement",NULL )
,		SchemaEntry("b_spline_curve_form",NULL )
,		SchemaEntry("b_spline_surface_form",NULL )
,		SchemaEntry("base_solid_select",NULL )
,		SchemaEntry("blend_end_condition_select",NULL )
,		SchemaEntry("blend_radius_variation_type",NULL )
,		SchemaEntry("boolean_operand",NULL )
,		SchemaEntry("boolean_operator",NULL )
,		SchemaEntry("box_characteristic_select",NULL )
,		SchemaEntry("box_height",NULL )
,		SchemaEntry("box_rotate_angle",NULL )
,		SchemaEntry("box_slant_angle",NULL )
,		SchemaEntry("box_width",NULL )
,		SchemaEntry("camera_model_d3_multi_clipping_interection_select",NULL )
,		SchemaEntry("camera_model_d3_multi_clipping_union_select",NULL )
,		SchemaEntry("capacitance_measure",NULL )
,		SchemaEntry("category_usage_item",NULL )
,		SchemaEntry("cc_classified_item",NULL )
,		SchemaEntry("cc_person_organization_item",NULL )
,		SchemaEntry("cc_specified_item",NULL )
,		SchemaEntry("celsius_temperature_measure",NULL )
,		SchemaEntry("central_or_parallel",NULL )
,		SchemaEntry("certification_item",NULL )
,		SchemaEntry("certified_item",NULL )
,		SchemaEntry("change_request_item",NULL )
,		SchemaEntry("character_spacing_select",NULL )
,		SchemaEntry("character_style_select",NULL )
,		SchemaEntry("characterized_action_definition",NULL )
,		SchemaEntry("characterized_definition",NULL )
,		SchemaEntry("characterized_material_property",NULL )
,		SchemaEntry("characterized_product_composition_value",NULL )
,		SchemaEntry("characterized_product_definition",NULL )
,		SchemaEntry("class_usage_effectivity_context_item",NULL )
,		SchemaEntry("classification_item",NULL )
,		SchemaEntry("classified_item",NULL )
,		SchemaEntry("compound_item_definition",NULL )
,		SchemaEntry("conductance_measure",NULL )
,		SchemaEntry("configuration_design_item",NULL )
,		SchemaEntry("configured_effectivity_context_item",NULL )
,		SchemaEntry("configured_effectivity_item",NULL )
,		SchemaEntry("constructive_geometry_representation_or_shape_represenation",NULL )
,		SchemaEntry("context_dependent_measure",NULL )
,		SchemaEntry("contract_item",NULL )
,		SchemaEntry("contracted_item",NULL )
,		SchemaEntry("count_measure",NULL )
,		SchemaEntry("csg_primitive",NULL )
,		SchemaEntry("csg_select",NULL )
,		SchemaEntry("curve_font_or_scaled_curve_font_select",NULL )
,		SchemaEntry("curve_on_surface",NULL )
,		SchemaEntry("curve_or_annotation_curve_occurrence",NULL )
,		SchemaEntry("curve_or_render",NULL )
,		SchemaEntry("curve_style_font_select",NULL )
,		SchemaEntry("date_and_time_item",NULL )
,		SchemaEntry("date_item",NULL )
,		SchemaEntry("date_time_item",NULL )
,		SchemaEntry("date_time_or_event_occurrence",NULL )
,		SchemaEntry("date_time_select",NULL )
,		SchemaEntry("day_in_month_number",NULL )
,		SchemaEntry("day_in_week_number",NULL )
,		SchemaEntry("day_in_year_number",NULL )
,		SchemaEntry("defined_symbol_select",NULL )
,		SchemaEntry("derived_property_select",NULL )
,		SchemaEntry("description_attribute_select",NULL )
,		SchemaEntry("descriptive_measure",NULL )
,		SchemaEntry("dimension_count",NULL )
,		SchemaEntry("dimension_extent_usage",NULL )
,		SchemaEntry("dimensional_characteristic",NULL )
,		SchemaEntry("direction_count_select",NULL )
,		SchemaEntry("document_identifier_assigned_item",NULL )
,		SchemaEntry("document_reference_item",NULL )
,		SchemaEntry("dose_equivalent_measure",NULL )
,		SchemaEntry("draughting_callout_element",NULL )
,		SchemaEntry("draughting_model_item_association_select",NULL )
,		SchemaEntry("draughting_model_item_select",NULL )
,		SchemaEntry("draughting_titled_item",NULL )
,		SchemaEntry("effectivity_item",NULL )
,		SchemaEntry("electric_charge_measure",NULL )
,		SchemaEntry("electric_current_measure",NULL )
,		SchemaEntry("electric_potential_measure",NULL )
,		SchemaEntry("energy_measure",NULL )
,		SchemaEntry("event_occurrence_item",NULL )
,		SchemaEntry("external_identification_item",NULL )
,		SchemaEntry("fill_area_style_tile_shape_select",NULL )
,		SchemaEntry("fill_style_select",NULL )
,		SchemaEntry("font_select",NULL )
,		SchemaEntry("force_measure",NULL )
,		SchemaEntry("founded_item_select",NULL )
,		SchemaEntry("frequency_measure",NULL )
,		SchemaEntry("generalized_surface_select",NULL )
,		SchemaEntry("geometric_item_specific_usage_select",NULL )
,		SchemaEntry("geometric_set_select",NULL )
,		SchemaEntry("groupable_item",NULL )
,		SchemaEntry("hour_in_day",NULL )
,		SchemaEntry("id_attribute_select",NULL )
,		SchemaEntry("identification_item",NULL )
,		SchemaEntry("identifier",NULL )
,		SchemaEntry("illuminance_measure",NULL )
,		SchemaEntry("inductance_measure",NULL )
,		SchemaEntry("instance_usage_context_select",NULL )
,		SchemaEntry("invisibility_context",NULL )
,		SchemaEntry("invisible_item",NULL )
,		SchemaEntry("ir_usage_item",NULL )
,		SchemaEntry("knot_type",NULL )
,		SchemaEntry("label",NULL )
,		SchemaEntry("layered_item",NULL )
,		SchemaEntry("length_measure",NULL )
,		SchemaEntry("limit_condition",NULL )
,		SchemaEntry("list_of_reversible_topology_item",NULL )
,		SchemaEntry("list_representation_item",NULL )
,		SchemaEntry("luminous_flux_measure",NULL )
,		SchemaEntry("luminous_intensity_measure",NULL )
,		SchemaEntry("magnetic_flux_density_measure",NULL )
,		SchemaEntry("magnetic_flux_measure",NULL )
,		SchemaEntry("marker_select",NULL )
,		SchemaEntry("marker_type",NULL )
,		SchemaEntry("mass_measure",NULL )
,		SchemaEntry("measure_value",NULL )
,		SchemaEntry("mechanical_design_and_draughting_relationship_select",NULL )
,		SchemaEntry("mechanical_design_geometric_presentation_area_items",NULL )
,		SchemaEntry("mechanical_design_geometric_presentation_representation_items",NULL )
,		SchemaEntry("message",NULL )
,		SchemaEntry("minute_in_hour",NULL )
,		SchemaEntry("month_in_year_number",NULL )
,		SchemaEntry("multi_language_attribute_item",NULL )
,		SchemaEntry("name_attribute_select",NULL )
,		SchemaEntry("name_item",NULL )
,		SchemaEntry("non_negative_length_measure",NULL )
,		SchemaEntry("nonnegative_integer",NULL )
,		SchemaEntry("null_style",NULL )
,		SchemaEntry("numeric_measure",NULL )
,		SchemaEntry("organization_item",NULL )
,		SchemaEntry("orientation_basis_select",NULL )
,		SchemaEntry("parameter_value",NULL )
,		SchemaEntry("pcurve_or_surface",NULL )
,		SchemaEntry("person_and_organization_item",NULL )
,		SchemaEntry("person_organization_select",NULL )
,		SchemaEntry("picture_representation_item_select",NULL )
,		SchemaEntry("plane_angle_measure",NULL )
,		SchemaEntry("plane_or_planar_box",NULL )
,		SchemaEntry("point_and_vector_member",NULL )
,		SchemaEntry("point_and_vector_members",NULL )
,		SchemaEntry("point_path_members",NULL )
,		SchemaEntry("positive_integer",NULL )
,		SchemaEntry("positive_length_measure",NULL )
,		SchemaEntry("positive_plane_angle_measure",NULL )
,		SchemaEntry("positive_ratio_measure",NULL )
,		SchemaEntry("power_measure",NULL )
,		SchemaEntry("preferred_surface_curve_representation",NULL )
,		SchemaEntry("presentable_text",NULL )
,		SchemaEntry("presentation_representation_select",NULL )
,		SchemaEntry("presentation_size_assignment_select",NULL )
,		SchemaEntry("presentation_style_select",NULL )
,		SchemaEntry("presented_item_select",NULL )
,		SchemaEntry("pressure_measure",NULL )
,		SchemaEntry("product_definition_or_assembly_relationship",NULL )
,		SchemaEntry("product_definition_or_breakdown_element_usage",NULL )
,		SchemaEntry("product_definition_or_product_definition_relationship",NULL )
,		SchemaEntry("product_or_formation_or_definition",NULL )
,		SchemaEntry("project_item",NULL )
,		SchemaEntry("radioactivity_measure",NULL )
,		SchemaEntry("ratio_measure",NULL )
,		SchemaEntry("rendering_properties_select",NULL )
,		SchemaEntry("represented_definition",NULL )
,		SchemaEntry("requirement_assigned_item",NULL )
,		SchemaEntry("requirement_satisfaction_item",NULL )
,		SchemaEntry("requirement_source_item",NULL )
,		SchemaEntry("resistance_measure",NULL )
,		SchemaEntry("reversible_topology",NULL )
,		SchemaEntry("reversible_topology_item",NULL )
,		SchemaEntry("role_select",NULL )
,		SchemaEntry("rule_superseded_item",NULL )
,		SchemaEntry("second_in_minute",NULL )
,		SchemaEntry("security_classification_item",NULL )
,		SchemaEntry("set_of_reversible_topology_item",NULL )
,		SchemaEntry("set_representation_item",NULL )
,		SchemaEntry("shading_curve_method",NULL )
,		SchemaEntry("shading_surface_method",NULL )
,		SchemaEntry("shape_definition",NULL )
,		SchemaEntry("shell",NULL )
,		SchemaEntry("si_prefix",NULL )
,		SchemaEntry("si_unit_name",NULL )
,		SchemaEntry("size_select",NULL )
,		SchemaEntry("sketch_basis_select",NULL )
,		SchemaEntry("solid_angle_measure",NULL )
,		SchemaEntry("source",NULL )
,		SchemaEntry("source_item",NULL )
,		SchemaEntry("start_request_item",NULL )
,		SchemaEntry("string_representation_item_select",NULL )
,		SchemaEntry("style_context_select",NULL )
,		SchemaEntry("surface_side",NULL )
,		SchemaEntry("surface_side_style_select",NULL )
,		SchemaEntry("surface_style_element_select",NULL )
,		SchemaEntry("symbol_style_select",NULL )
,		SchemaEntry("text",NULL )
,		SchemaEntry("text_alignment",NULL )
,		SchemaEntry("text_delineation",NULL )
,		SchemaEntry("text_or_character",NULL )
,		SchemaEntry("text_path",NULL )
,		SchemaEntry("text_string_representation_item",NULL )
,		SchemaEntry("thermodynamic_temperature_measure",NULL )
,		SchemaEntry("time_interval_item",NULL )
,		SchemaEntry("time_measure",NULL )
,		SchemaEntry("tolerance_method_definition",NULL )
,		SchemaEntry("transformation",NULL )
,		SchemaEntry("transition_code",NULL )
,		SchemaEntry("trim_condition_select",NULL )
,		SchemaEntry("trim_intent",NULL )
,		SchemaEntry("trimming_preference",NULL )
,		SchemaEntry("trimming_select",NULL )
,		SchemaEntry("u_direction_count",NULL )
,		SchemaEntry("unit",NULL )
,		SchemaEntry("v_direction_count",NULL )
,		SchemaEntry("value_qualifier",NULL )
,		SchemaEntry("vector_or_direction",NULL )
,		SchemaEntry("velocity_measure",NULL )
,		SchemaEntry("volume_measure",NULL )
,		SchemaEntry("week_in_year_number",NULL )
,		SchemaEntry("work_item",NULL )
,		SchemaEntry("year_number",NULL )
,		SchemaEntry("measure_with_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("absorbed_dose_measure_with_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("derived_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("absorbed_dose_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("representation_item",&STEP::ObjectHelper<STEPRepresentation_Item,1>::Construct )
,		SchemaEntry("representation",&STEP::ObjectHelper<STEPRepresentation,3>::Construct )
,		SchemaEntry("property_definition_representation",&STEP::ObjectHelper<STEPProperty_Definition_Representation,2>::Construct )
,		SchemaEntry("property_definition",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("abstract_variable",&STEP::ObjectHelper<STEPAbstract_Variable,0>::Construct )
,		SchemaEntry("acceleration_measure_with_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("acceleration_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("action",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("action_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("action_directive",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("action_method",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("action_method_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("action_method_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("action_method_role",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("action_property",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("action_property_representation",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("action_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("action_request_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("action_request_solution",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("action_request_status",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("action_status",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("address",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("shape_representation",&STEP::ObjectHelper<STEPShape_Representation,0>::Construct )
,		SchemaEntry("advanced_brep_shape_representation",&STEP::ObjectHelper<STEPAdvanced_Brep_Shape_Representation,0>::Construct )
,		SchemaEntry("topological_representation_item",&STEP::ObjectHelper<STEPTopological_Representation_Item,0>::Construct )
,		SchemaEntry("geometric_representation_item",&STEP::ObjectHelper<STEPGeometric_Representation_Item,0>::Construct )
,		SchemaEntry("face",&STEP::ObjectHelper<STEPFace,1>::Construct )
,		SchemaEntry("face_surface",&STEP::ObjectHelper<STEPFace_Surface,2>::Construct )
,		SchemaEntry("advanced_face",&STEP::ObjectHelper<STEPAdvanced_Face,0>::Construct )
,		SchemaEntry("alternate_product_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("amount_of_substance_measure_with_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("named_unit",&STEP::ObjectHelper<STEPNamed_Unit,1>::Construct )
,		SchemaEntry("amount_of_substance_unit",&STEP::ObjectHelper<STEPAmount_Of_Substance_Unit,0>::Construct )
,		SchemaEntry("representation_item_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("angle_direction_reference",&STEP::ObjectHelper<STEPAngle_Direction_Reference,0>::Construct )
,		SchemaEntry("draughting_callout",&STEP::ObjectHelper<STEPDraughting_Callout,1>::Construct )
,		SchemaEntry("dimension_curve_directed_callout",&STEP::ObjectHelper<STEPDimension_Curve_Directed_Callout,0>::Construct )
,		SchemaEntry("angular_dimension",&STEP::ObjectHelper<STEPAngular_Dimension,0>::Construct )
,		SchemaEntry("shape_aspect_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("dimensional_location",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("angular_location",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("dimensional_size",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("angular_size",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("geometric_tolerance",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("geometric_tolerance_with_datum_reference",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("angularity_tolerance",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("styled_item",&STEP::ObjectHelper<STEPStyled_Item,2>::Construct )
,		SchemaEntry("annotation_occurrence",&STEP::ObjectHelper<STEPAnnotation_Occurrence,0>::Construct )
,		SchemaEntry("annotation_curve_occurrence",&STEP::ObjectHelper<STEPAnnotation_Curve_Occurrence,0>::Construct )
,		SchemaEntry("annotation_fill_area",&STEP::ObjectHelper<STEPAnnotation_Fill_Area,1>::Construct )
,		SchemaEntry("annotation_fill_area_occurrence",&STEP::ObjectHelper<STEPAnnotation_Fill_Area_Occurrence,1>::Construct )
,		SchemaEntry("annotation_occurrence_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("annotation_occurrence_associativity",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("annotation_plane",&STEP::ObjectHelper<STEPAnnotation_Plane,1>::Construct )
,		SchemaEntry("annotation_symbol_occurrence",&STEP::ObjectHelper<STEPAnnotation_Symbol_Occurrence,0>::Construct )
,		SchemaEntry("annotation_subfigure_occurrence",&STEP::ObjectHelper<STEPAnnotation_Subfigure_Occurrence,0>::Construct )
,		SchemaEntry("mapped_item",&STEP::ObjectHelper<STEPMapped_Item,2>::Construct )
,		SchemaEntry("annotation_symbol",&STEP::ObjectHelper<STEPAnnotation_Symbol,0>::Construct )
,		SchemaEntry("annotation_text",&STEP::ObjectHelper<STEPAnnotation_Text,0>::Construct )
,		SchemaEntry("annotation_text_character",&STEP::ObjectHelper<STEPAnnotation_Text_Character,1>::Construct )
,		SchemaEntry("annotation_text_occurrence",&STEP::ObjectHelper<STEPAnnotation_Text_Occurrence,0>::Construct )
,		SchemaEntry("shape_aspect",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("derived_shape_aspect",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("apex",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("application_context",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("application_context_element",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("application_protocol_definition",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("applied_action_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("applied_action_method_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("applied_action_request_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("approval_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("applied_approval_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("attribute_classification_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("applied_attribute_classification_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("certification_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("applied_certification_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("classification_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("applied_classification_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("contract_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("applied_contract_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("date_and_time_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("applied_date_and_time_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("date_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("applied_date_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("document_reference",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("applied_document_reference",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("document_usage_constraint_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("applied_document_usage_constraint_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("effectivity_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("applied_effectivity_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("event_occurrence_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("applied_event_occurrence_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("identification_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("external_identification_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("applied_external_identification_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("group_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("applied_group_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("applied_identification_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("name_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("applied_name_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("organization_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("applied_organization_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("organizational_project_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("applied_organizational_project_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("person_and_organization_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("applied_person_and_organization_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("presented_item",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("applied_presented_item",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("security_classification_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("applied_security_classification_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("time_interval_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("applied_time_interval_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("applied_usage_right",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("approval",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("approval_date_time",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("approval_person_organization",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("approval_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("approval_role",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("approval_status",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("area_in_set",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("area_measure_with_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("area_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("product_definition_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("product_definition_usage",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("assembly_component_usage",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("assembly_component_usage_substitute",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("assigned_requirement",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("compound_representation_item",&STEP::ObjectHelper<STEPCompound_Representation_Item,1>::Construct )
,		SchemaEntry("atomic_formula",&STEP::ObjectHelper<STEPAtomic_Formula,0>::Construct )
,		SchemaEntry("fact_type",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("attribute_assertion",&STEP::ObjectHelper<STEPAttribute_Assertion,0>::Construct )
,		SchemaEntry("attribute_language_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("attribute_value_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("attribute_value_role",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("variational_representation_item",&STEP::ObjectHelper<STEPVariational_Representation_Item,0>::Construct )
,		SchemaEntry("auxiliary_geometric_representation_item",&STEP::ObjectHelper<STEPAuxiliary_Geometric_Representation_Item,0>::Construct )
,		SchemaEntry("placement",&STEP::ObjectHelper<STEPPlacement,1>::Construct )
,		SchemaEntry("axis1_placement",&STEP::ObjectHelper<STEPAxis1_Placement,1>::Construct )
,		SchemaEntry("axis2_placement_2d",&STEP::ObjectHelper<STEPAxis2_Placement_2d,1>::Construct )
,		SchemaEntry("axis2_placement_3d",&STEP::ObjectHelper<STEPAxis2_Placement_3d,2>::Construct )
,		SchemaEntry("curve",&STEP::ObjectHelper<STEPCurve,0>::Construct )
,		SchemaEntry("bounded_curve",&STEP::ObjectHelper<STEPBounded_Curve,0>::Construct )
,		SchemaEntry("b_spline_curve",&STEP::ObjectHelper<STEPB_Spline_Curve,5>::Construct )
,		SchemaEntry("b_spline_curve_with_knots",&STEP::ObjectHelper<STEPB_Spline_Curve_With_Knots,3>::Construct )
,		SchemaEntry("surface",&STEP::ObjectHelper<STEPSurface,0>::Construct )
,		SchemaEntry("bounded_surface",&STEP::ObjectHelper<STEPBounded_Surface,0>::Construct )
,		SchemaEntry("b_spline_surface",&STEP::ObjectHelper<STEPB_Spline_Surface,6>::Construct )
,		SchemaEntry("b_spline_surface_with_knots",&STEP::ObjectHelper<STEPB_Spline_Surface_With_Knots,5>::Construct )
,		SchemaEntry("product_definition",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("rule_software_definition",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("rule_definition",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("back_chaining_rule",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("back_chaining_rule_body",&STEP::ObjectHelper<STEPBack_Chaining_Rule_Body,0>::Construct )
,		SchemaEntry("colour",&STEP::ObjectHelper<STEPColour,0>::Construct )
,		SchemaEntry("background_colour",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("beveled_sheet_representation",&STEP::ObjectHelper<STEPBeveled_Sheet_Representation,0>::Construct )
,		SchemaEntry("bezier_curve",&STEP::ObjectHelper<STEPBezier_Curve,0>::Construct )
,		SchemaEntry("bezier_surface",&STEP::ObjectHelper<STEPBezier_Surface,0>::Construct )
,		SchemaEntry("generic_expression",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("binary_generic_expression",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("expression",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("numeric_expression",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("binary_numeric_expression",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("binary_representation_item",&STEP::ObjectHelper<STEPBinary_Representation_Item,1>::Construct )
,		SchemaEntry("block",&STEP::ObjectHelper<STEPBlock,4>::Construct )
,		SchemaEntry("boolean_expression",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("simple_generic_expression",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("generic_literal",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("simple_boolean_expression",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("boolean_literal",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("boolean_representation_item",&STEP::ObjectHelper<STEPBoolean_Representation_Item,0>::Construct )
,		SchemaEntry("boolean_result",&STEP::ObjectHelper<STEPBoolean_Result,3>::Construct )
,		SchemaEntry("composite_curve",&STEP::ObjectHelper<STEPComposite_Curve,2>::Construct )
,		SchemaEntry("composite_curve_on_surface",&STEP::ObjectHelper<STEPComposite_Curve_On_Surface,0>::Construct )
,		SchemaEntry("boundary_curve",&STEP::ObjectHelper<STEPBoundary_Curve,0>::Construct )
,		SchemaEntry("pcurve",&STEP::ObjectHelper<STEPPcurve,2>::Construct )
,		SchemaEntry("bounded_pcurve",&STEP::ObjectHelper<STEPBounded_Pcurve,0>::Construct )
,		SchemaEntry("surface_curve",&STEP::ObjectHelper<STEPSurface_Curve,3>::Construct )
,		SchemaEntry("bounded_surface_curve",&STEP::ObjectHelper<STEPBounded_Surface_Curve,0>::Construct )
,		SchemaEntry("founded_item",&STEP::ObjectHelper<STEPFounded_Item,0>::Construct )
,		SchemaEntry("box_domain",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("half_space_solid",&STEP::ObjectHelper<STEPHalf_Space_Solid,2>::Construct )
,		SchemaEntry("boxed_half_space",&STEP::ObjectHelper<STEPBoxed_Half_Space,1>::Construct )
,		SchemaEntry("breakdown_context",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("breakdown_element_group_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("group",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("product_definition_element_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("characterized_object",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("breakdown_element_realization",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("breakdown_element_usage",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("breakdown_of",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("solid_model",&STEP::ObjectHelper<STEPSolid_Model,0>::Construct )
,		SchemaEntry("manifold_solid_brep",&STEP::ObjectHelper<STEPManifold_Solid_Brep,1>::Construct )
,		SchemaEntry("brep_with_voids",&STEP::ObjectHelper<STEPBrep_With_Voids,1>::Construct )
,		SchemaEntry("bytes_representation_item",&STEP::ObjectHelper<STEPBytes_Representation_Item,0>::Construct )
,		SchemaEntry("date",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("calendar_date",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("camera_image",&STEP::ObjectHelper<STEPCamera_Image,0>::Construct )
,		SchemaEntry("camera_image_3d_with_scale",&STEP::ObjectHelper<STEPCamera_Image_3d_With_Scale,0>::Construct )
,		SchemaEntry("camera_model",&STEP::ObjectHelper<STEPCamera_Model,0>::Construct )
,		SchemaEntry("camera_model_d3",&STEP::ObjectHelper<STEPCamera_Model_D3,2>::Construct )
,		SchemaEntry("camera_model_d3_multi_clipping",&STEP::ObjectHelper<STEPCamera_Model_D3_Multi_Clipping,1>::Construct )
,		SchemaEntry("camera_model_d3_multi_clipping_intersection",&STEP::ObjectHelper<STEPCamera_Model_D3_Multi_Clipping_Intersection,1>::Construct )
,		SchemaEntry("camera_model_d3_multi_clipping_union",&STEP::ObjectHelper<STEPCamera_Model_D3_Multi_Clipping_Union,1>::Construct )
,		SchemaEntry("camera_model_d3_with_hlhsr",&STEP::ObjectHelper<STEPCamera_Model_D3_With_Hlhsr,1>::Construct )
,		SchemaEntry("camera_model_with_light_sources",&STEP::ObjectHelper<STEPCamera_Model_With_Light_Sources,1>::Construct )
,		SchemaEntry("representation_map",&STEP::ObjectHelper<STEPRepresentation_Map,2>::Construct )
,		SchemaEntry("camera_usage",&STEP::ObjectHelper<STEPCamera_Usage,0>::Construct )
,		SchemaEntry("capacitance_measure_with_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("capacitance_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("point",&STEP::ObjectHelper<STEPPoint,0>::Construct )
,		SchemaEntry("cartesian_point",&STEP::ObjectHelper<STEPCartesian_Point,1>::Construct )
,		SchemaEntry("functionally_defined_transformation",&STEP::ObjectHelper<STEPFunctionally_Defined_Transformation,2>::Construct )
,		SchemaEntry("cartesian_transformation_operator",&STEP::ObjectHelper<STEPCartesian_Transformation_Operator,4>::Construct )
,		SchemaEntry("cartesian_transformation_operator_2d",&STEP::ObjectHelper<STEPCartesian_Transformation_Operator_2d,0>::Construct )
,		SchemaEntry("cartesian_transformation_operator_3d",&STEP::ObjectHelper<STEPCartesian_Transformation_Operator_3d,1>::Construct )
,		SchemaEntry("cc_design_approval",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("cc_design_certification",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("cc_design_contract",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("cc_design_date_and_time_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("cc_design_person_and_organization_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("cc_design_security_classification",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("cc_design_specification_reference",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("celsius_temperature_measure_with_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("centre_of_symmetry",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("certification",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("certification_type",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("change",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("change_request",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("character_glyph_font_usage",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("character_glyph_style_outline",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("character_glyph_style_stroke",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("symbol_representation",&STEP::ObjectHelper<STEPSymbol_Representation,0>::Construct )
,		SchemaEntry("generic_character_glyph_symbol",&STEP::ObjectHelper<STEPGeneric_Character_Glyph_Symbol,0>::Construct )
,		SchemaEntry("character_glyph_symbol",&STEP::ObjectHelper<STEPCharacter_Glyph_Symbol,2>::Construct )
,		SchemaEntry("character_glyph_symbol_outline",&STEP::ObjectHelper<STEPCharacter_Glyph_Symbol_Outline,1>::Construct )
,		SchemaEntry("character_glyph_symbol_stroke",&STEP::ObjectHelper<STEPCharacter_Glyph_Symbol_Stroke,1>::Construct )
,		SchemaEntry("general_property",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("characteristic_data_column_header",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("general_property_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("characteristic_data_column_header_link",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("characteristic_data_table_header",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("characteristic_data_table_header_decomposition",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("characteristic_type",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("class",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("characterized_class",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("conic",&STEP::ObjectHelper<STEPConic,1>::Construct )
,		SchemaEntry("circle",&STEP::ObjectHelper<STEPCircle,1>::Construct )
,		SchemaEntry("circular_runout_tolerance",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("class_by_extension",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("class_by_intension",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("class_system",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("effectivity_context_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("class_usage_effectivity_context_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("classification_role",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("connected_face_set",&STEP::ObjectHelper<STEPConnected_Face_Set,1>::Construct )
,		SchemaEntry("closed_shell",&STEP::ObjectHelper<STEPClosed_Shell,0>::Construct )
,		SchemaEntry("coaxiality_tolerance",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("colour_specification",&STEP::ObjectHelper<STEPColour_Specification,1>::Construct )
,		SchemaEntry("colour_rgb",&STEP::ObjectHelper<STEPColour_Rgb,3>::Construct )
,		SchemaEntry("datum",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("composite_shape_aspect",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("common_datum",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("comparison_expression",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("complex_clause",&STEP::ObjectHelper<STEPComplex_Clause,0>::Construct )
,		SchemaEntry("complex_conjunctive_clause",&STEP::ObjectHelper<STEPComplex_Conjunctive_Clause,0>::Construct )
,		SchemaEntry("complex_disjunctive_clause",&STEP::ObjectHelper<STEPComplex_Disjunctive_Clause,0>::Construct )
,		SchemaEntry("modified_solid",&STEP::ObjectHelper<STEPModified_Solid,2>::Construct )
,		SchemaEntry("shelled_solid",&STEP::ObjectHelper<STEPShelled_Solid,2>::Construct )
,		SchemaEntry("complex_shelled_solid",&STEP::ObjectHelper<STEPComplex_Shelled_Solid,1>::Construct )
,		SchemaEntry("composite_assembly_definition",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("composite_assembly_sequence_definition",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("laminate_table",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("part_laminate_table",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("composite_assembly_table",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("composite_curve_segment",&STEP::ObjectHelper<STEPComposite_Curve_Segment,3>::Construct )
,		SchemaEntry("material_designation",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("composite_material_designation",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("composite_sheet_representation",&STEP::ObjectHelper<STEPComposite_Sheet_Representation,0>::Construct )
,		SchemaEntry("composite_text",&STEP::ObjectHelper<STEPComposite_Text,1>::Construct )
,		SchemaEntry("composite_text_with_associated_curves",&STEP::ObjectHelper<STEPComposite_Text_With_Associated_Curves,1>::Construct )
,		SchemaEntry("composite_text_with_blanking_box",&STEP::ObjectHelper<STEPComposite_Text_With_Blanking_Box,1>::Construct )
,		SchemaEntry("composite_text_with_delineation",&STEP::ObjectHelper<STEPComposite_Text_With_Delineation,1>::Construct )
,		SchemaEntry("composite_text_with_extent",&STEP::ObjectHelper<STEPComposite_Text_With_Extent,1>::Construct )
,		SchemaEntry("compound_shape_representation",&STEP::ObjectHelper<STEPCompound_Shape_Representation,0>::Construct )
,		SchemaEntry("concentricity_tolerance",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("concept_feature_operator",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("concept_feature_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("concept_feature_relationship_with_condition",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("product_concept_feature",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("conditional_concept_feature",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("conductance_measure_with_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("conductance_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("configuration_item",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("configurable_item",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("configuration_design",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("effectivity",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("product_definition_effectivity",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("configuration_effectivity",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("configuration_item_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("configuration_item_hierarchical_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("configuration_item_revision_sequence",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("configured_effectivity_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("configured_effectivity_context_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("conical_stepped_hole_transition",&STEP::ObjectHelper<STEPConical_Stepped_Hole_Transition,3>::Construct )
,		SchemaEntry("elementary_surface",&STEP::ObjectHelper<STEPElementary_Surface,1>::Construct )
,		SchemaEntry("conical_surface",&STEP::ObjectHelper<STEPConical_Surface,2>::Construct )
,		SchemaEntry("connected_edge_set",&STEP::ObjectHelper<STEPConnected_Edge_Set,1>::Construct )
,		SchemaEntry("connected_face_sub_set",&STEP::ObjectHelper<STEPConnected_Face_Sub_Set,1>::Construct )
,		SchemaEntry("constructive_geometry_representation",&STEP::ObjectHelper<STEPConstructive_Geometry_Representation,0>::Construct )
,		SchemaEntry("representation_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("constructive_geometry_representation_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("contact_ratio_representation",&STEP::ObjectHelper<STEPContact_Ratio_Representation,0>::Construct )
,		SchemaEntry("invisibility",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("context_dependent_invisibility",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("over_riding_styled_item",&STEP::ObjectHelper<STEPOver_Riding_Styled_Item,1>::Construct )
,		SchemaEntry("context_dependent_over_riding_styled_item",&STEP::ObjectHelper<STEPContext_Dependent_Over_Riding_Styled_Item,1>::Construct )
,		SchemaEntry("context_dependent_shape_representation",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("context_dependent_unit",&STEP::ObjectHelper<STEPContext_Dependent_Unit,1>::Construct )
,		SchemaEntry("contract",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("contract_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("contract_type",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("conversion_based_unit",&STEP::ObjectHelper<STEPConversion_Based_Unit,2>::Construct )
,		SchemaEntry("coordinated_universal_time_offset",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("csg_shape_representation",&STEP::ObjectHelper<STEPCsg_Shape_Representation,0>::Construct )
,		SchemaEntry("csg_solid",&STEP::ObjectHelper<STEPCsg_Solid,1>::Construct )
,		SchemaEntry("currency",&STEP::ObjectHelper<STEPCurrency,0>::Construct )
,		SchemaEntry("currency_measure_with_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("curve_bounded_surface",&STEP::ObjectHelper<STEPCurve_Bounded_Surface,3>::Construct )
,		SchemaEntry("curve_dimension",&STEP::ObjectHelper<STEPCurve_Dimension,0>::Construct )
,		SchemaEntry("curve_replica",&STEP::ObjectHelper<STEPCurve_Replica,2>::Construct )
,		SchemaEntry("curve_style",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("curve_style_font",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("curve_style_font_and_scaling",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("curve_style_font_pattern",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("curve_style_rendering",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("curve_swept_solid_shape_representation",&STEP::ObjectHelper<STEPCurve_Swept_Solid_Shape_Representation,0>::Construct )
,		SchemaEntry("cylindrical_surface",&STEP::ObjectHelper<STEPCylindrical_Surface,1>::Construct )
,		SchemaEntry("cylindricity_tolerance",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("data_environment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("date_and_time",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("date_representation_item",&STEP::ObjectHelper<STEPDate_Representation_Item,0>::Construct )
,		SchemaEntry("date_role",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("date_time_representation_item",&STEP::ObjectHelper<STEPDate_Time_Representation_Item,0>::Construct )
,		SchemaEntry("date_time_role",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("dated_effectivity",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("datum_feature",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("datum_feature_callout",&STEP::ObjectHelper<STEPDatum_Feature_Callout,0>::Construct )
,		SchemaEntry("datum_reference",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("datum_target",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("datum_target_callout",&STEP::ObjectHelper<STEPDatum_Target_Callout,0>::Construct )
,		SchemaEntry("default_tolerance_table",&STEP::ObjectHelper<STEPDefault_Tolerance_Table,0>::Construct )
,		SchemaEntry("default_tolerance_table_cell",&STEP::ObjectHelper<STEPDefault_Tolerance_Table_Cell,0>::Construct )
,		SchemaEntry("defined_symbol",&STEP::ObjectHelper<STEPDefined_Symbol,2>::Construct )
,		SchemaEntry("definitional_representation",&STEP::ObjectHelper<STEPDefinitional_Representation,0>::Construct )
,		SchemaEntry("definitional_representation_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("definitional_representation_relationship_with_same_context",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("degenerate_pcurve",&STEP::ObjectHelper<STEPDegenerate_Pcurve,2>::Construct )
,		SchemaEntry("toroidal_surface",&STEP::ObjectHelper<STEPToroidal_Surface,2>::Construct )
,		SchemaEntry("degenerate_toroidal_surface",&STEP::ObjectHelper<STEPDegenerate_Toroidal_Surface,1>::Construct )
,		SchemaEntry("derived_unit_element",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("description_attribute",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("descriptive_representation_item",&STEP::ObjectHelper<STEPDescriptive_Representation_Item,1>::Construct )
,		SchemaEntry("product_definition_context",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("design_context",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("design_make_from_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("diameter_dimension",&STEP::ObjectHelper<STEPDiameter_Dimension,0>::Construct )
,		SchemaEntry("ratio_measure_with_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("dielectric_constant_measure_with_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("dimension_callout",&STEP::ObjectHelper<STEPDimension_Callout,0>::Construct )
,		SchemaEntry("draughting_callout_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("dimension_callout_component_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("dimension_callout_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("dimension_curve",&STEP::ObjectHelper<STEPDimension_Curve,0>::Construct )
,		SchemaEntry("terminator_symbol",&STEP::ObjectHelper<STEPTerminator_Symbol,1>::Construct )
,		SchemaEntry("dimension_curve_terminator",&STEP::ObjectHelper<STEPDimension_Curve_Terminator,1>::Construct )
,		SchemaEntry("dimension_curve_terminator_to_projection_curve_associativity",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("dimension_pair",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("dimension_related_tolerance_zone_element",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("text_literal",&STEP::ObjectHelper<STEPText_Literal,5>::Construct )
,		SchemaEntry("dimension_text_associativity",&STEP::ObjectHelper<STEPDimension_Text_Associativity,0>::Construct )
,		SchemaEntry("dimensional_characteristic_representation",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("dimensional_exponents",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("dimensional_location_with_path",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("dimensional_size_with_path",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("executed_action",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("directed_action",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("directed_dimensional_location",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("direction",&STEP::ObjectHelper<STEPDirection,1>::Construct )
,		SchemaEntry("document",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("document_file",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("document_identifier",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("document_identifier_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("document_product_association",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("document_product_equivalence",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("document_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("document_representation_type",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("document_type",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("document_usage_constraint",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("document_usage_role",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("dose_equivalent_measure_with_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("dose_equivalent_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("double_offset_shelled_solid",&STEP::ObjectHelper<STEPDouble_Offset_Shelled_Solid,1>::Construct )
,		SchemaEntry("item_defined_transformation",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("transformation_with_derived_angle",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("draped_defined_transformation",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("draughting_annotation_occurrence",&STEP::ObjectHelper<STEPDraughting_Annotation_Occurrence,0>::Construct )
,		SchemaEntry("draughting_elements",&STEP::ObjectHelper<STEPDraughting_Elements,0>::Construct )
,		SchemaEntry("draughting_model",&STEP::ObjectHelper<STEPDraughting_Model,0>::Construct )
,		SchemaEntry("item_identified_representation_usage",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("draughting_model_item_association",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("pre_defined_item",&STEP::ObjectHelper<STEPPre_Defined_Item,1>::Construct )
,		SchemaEntry("pre_defined_colour",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("draughting_pre_defined_colour",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("pre_defined_curve_font",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("draughting_pre_defined_curve_font",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("pre_defined_text_font",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("draughting_pre_defined_text_font",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("draughting_subfigure_representation",&STEP::ObjectHelper<STEPDraughting_Subfigure_Representation,0>::Construct )
,		SchemaEntry("draughting_symbol_representation",&STEP::ObjectHelper<STEPDraughting_Symbol_Representation,0>::Construct )
,		SchemaEntry("text_literal_with_delineation",&STEP::ObjectHelper<STEPText_Literal_With_Delineation,1>::Construct )
,		SchemaEntry("draughting_text_literal_with_delineation",&STEP::ObjectHelper<STEPDraughting_Text_Literal_With_Delineation,0>::Construct )
,		SchemaEntry("draughting_title",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("drawing_definition",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("presentation_set",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("drawing_revision",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("drawing_revision_sequence",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("presentation_representation",&STEP::ObjectHelper<STEPPresentation_Representation,0>::Construct )
,		SchemaEntry("presentation_area",&STEP::ObjectHelper<STEPPresentation_Area,0>::Construct )
,		SchemaEntry("drawing_sheet_revision",&STEP::ObjectHelper<STEPDrawing_Sheet_Revision,1>::Construct )
,		SchemaEntry("drawing_sheet_revision_sequence",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("drawing_sheet_revision_usage",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("edge",&STEP::ObjectHelper<STEPEdge,2>::Construct )
,		SchemaEntry("edge_based_wireframe_model",&STEP::ObjectHelper<STEPEdge_Based_Wireframe_Model,1>::Construct )
,		SchemaEntry("edge_based_wireframe_shape_representation",&STEP::ObjectHelper<STEPEdge_Based_Wireframe_Shape_Representation,0>::Construct )
,		SchemaEntry("edge_blended_solid",&STEP::ObjectHelper<STEPEdge_Blended_Solid,1>::Construct )
,		SchemaEntry("edge_curve",&STEP::ObjectHelper<STEPEdge_Curve,2>::Construct )
,		SchemaEntry("path",&STEP::ObjectHelper<STEPPath,1>::Construct )
,		SchemaEntry("loop",&STEP::ObjectHelper<STEPLoop,0>::Construct )
,		SchemaEntry("edge_loop",&STEP::ObjectHelper<STEPEdge_Loop,0>::Construct )
,		SchemaEntry("effectivity_context_role",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("effectivity_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("electric_charge_measure_with_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("electric_charge_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("electric_current_measure_with_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("electric_current_unit",&STEP::ObjectHelper<STEPElectric_Current_Unit,0>::Construct )
,		SchemaEntry("electric_potential_measure_with_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("electric_potential_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("elementary_brep_shape_representation",&STEP::ObjectHelper<STEPElementary_Brep_Shape_Representation,0>::Construct )
,		SchemaEntry("ellipse",&STEP::ObjectHelper<STEPEllipse,2>::Construct )
,		SchemaEntry("energy_measure_with_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("energy_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("entity_assertion",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("enum_reference_prefix",&STEP::ObjectHelper<STEPEnum_Reference_Prefix,0>::Construct )
,		SchemaEntry("environment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("evaluated_characteristic",&STEP::ObjectHelper<STEPEvaluated_Characteristic,0>::Construct )
,		SchemaEntry("evaluated_degenerate_pcurve",&STEP::ObjectHelper<STEPEvaluated_Degenerate_Pcurve,1>::Construct )
,		SchemaEntry("evaluation_product_definition",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("event_occurrence",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("event_occurrence_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("event_occurrence_role",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("product_concept_feature_category",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("exclusive_product_concept_feature_category",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("uncertainty_qualifier",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("standard_uncertainty",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("expanded_uncertainty",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("explicit_procedural_representation_item_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("explicit_procedural_geometric_representation_item_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("explicit_procedural_representation_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("explicit_procedural_shape_representation_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("variable_semantics",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("expression_conversion_based_unit",&STEP::ObjectHelper<STEPExpression_Conversion_Based_Unit,0>::Construct )
,		SchemaEntry("extension",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("extent",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("external_source",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("external_class_library",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("external_source_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("externally_defined_item",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("externally_defined_class",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("externally_defined_colour",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("externally_defined_context_dependent_unit",&STEP::ObjectHelper<STEPExternally_Defined_Context_Dependent_Unit,0>::Construct )
,		SchemaEntry("externally_defined_conversion_based_unit",&STEP::ObjectHelper<STEPExternally_Defined_Conversion_Based_Unit,0>::Construct )
,		SchemaEntry("externally_defined_currency",&STEP::ObjectHelper<STEPExternally_Defined_Currency,0>::Construct )
,		SchemaEntry("externally_defined_curve_font",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("externally_defined_dimension_definition",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("externally_defined_general_property",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("externally_defined_hatch_style",&STEP::ObjectHelper<STEPExternally_Defined_Hatch_Style,0>::Construct )
,		SchemaEntry("externally_defined_item_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("pre_defined_marker",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("externally_defined_symbol",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("externally_defined_marker",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("picture_representation_item",&STEP::ObjectHelper<STEPPicture_Representation_Item,0>::Construct )
,		SchemaEntry("externally_defined_picture_representation_item",&STEP::ObjectHelper<STEPExternally_Defined_Picture_Representation_Item,0>::Construct )
,		SchemaEntry("externally_defined_representation_item",&STEP::ObjectHelper<STEPExternally_Defined_Representation_Item,0>::Construct )
,		SchemaEntry("externally_defined_string",&STEP::ObjectHelper<STEPExternally_Defined_String,0>::Construct )
,		SchemaEntry("externally_defined_terminator_symbol",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("externally_defined_text_font",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("externally_defined_tile",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("externally_defined_tile_style",&STEP::ObjectHelper<STEPExternally_Defined_Tile_Style,0>::Construct )
,		SchemaEntry("swept_area_solid",&STEP::ObjectHelper<STEPSwept_Area_Solid,1>::Construct )
,		SchemaEntry("extruded_area_solid",&STEP::ObjectHelper<STEPExtruded_Area_Solid,2>::Construct )
,		SchemaEntry("swept_face_solid",&STEP::ObjectHelper<STEPSwept_Face_Solid,1>::Construct )
,		SchemaEntry("extruded_face_solid",&STEP::ObjectHelper<STEPExtruded_Face_Solid,2>::Construct )
,		SchemaEntry("extruded_face_solid_with_trim_conditions",&STEP::ObjectHelper<STEPExtruded_Face_Solid_With_Trim_Conditions,6>::Construct )
,		SchemaEntry("extruded_face_solid_with_draft_angle",&STEP::ObjectHelper<STEPExtruded_Face_Solid_With_Draft_Angle,1>::Construct )
,		SchemaEntry("extruded_face_solid_with_multiple_draft_angles",&STEP::ObjectHelper<STEPExtruded_Face_Solid_With_Multiple_Draft_Angles,1>::Construct )
,		SchemaEntry("face_based_surface_model",&STEP::ObjectHelper<STEPFace_Based_Surface_Model,1>::Construct )
,		SchemaEntry("face_bound",&STEP::ObjectHelper<STEPFace_Bound,2>::Construct )
,		SchemaEntry("face_outer_bound",&STEP::ObjectHelper<STEPFace_Outer_Bound,0>::Construct )
,		SchemaEntry("faceted_brep",&STEP::ObjectHelper<STEPFaceted_Brep,0>::Construct )
,		SchemaEntry("faceted_brep_shape_representation",&STEP::ObjectHelper<STEPFaceted_Brep_Shape_Representation,0>::Construct )
,		SchemaEntry("fill_area_style",&STEP::ObjectHelper<STEPFill_Area_Style,2>::Construct )
,		SchemaEntry("fill_area_style_colour",&STEP::ObjectHelper<STEPFill_Area_Style_Colour,2>::Construct )
,		SchemaEntry("fill_area_style_hatching",&STEP::ObjectHelper<STEPFill_Area_Style_Hatching,5>::Construct )
,		SchemaEntry("fill_area_style_tile_coloured_region",&STEP::ObjectHelper<STEPFill_Area_Style_Tile_Coloured_Region,2>::Construct )
,		SchemaEntry("fill_area_style_tile_curve_with_style",&STEP::ObjectHelper<STEPFill_Area_Style_Tile_Curve_With_Style,1>::Construct )
,		SchemaEntry("fill_area_style_tile_symbol_with_style",&STEP::ObjectHelper<STEPFill_Area_Style_Tile_Symbol_With_Style,1>::Construct )
,		SchemaEntry("fill_area_style_tiles",&STEP::ObjectHelper<STEPFill_Area_Style_Tiles,3>::Construct )
,		SchemaEntry("shape_representation_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("flat_pattern_ply_representation_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("flatness_tolerance",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("force_measure_with_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("force_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("forward_chaining_rule",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("forward_chaining_rule_premise",&STEP::ObjectHelper<STEPForward_Chaining_Rule_Premise,0>::Construct )
,		SchemaEntry("frequency_measure_with_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("frequency_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("func",&STEP::ObjectHelper<STEPFunc,0>::Construct )
,		SchemaEntry("functional_breakdown_context",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("functional_element_usage",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("general_material_property",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("general_property_association",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("generic_variable",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("geometric_alignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("geometric_set",&STEP::ObjectHelper<STEPGeometric_Set,1>::Construct )
,		SchemaEntry("geometric_curve_set",&STEP::ObjectHelper<STEPGeometric_Curve_Set,0>::Construct )
,		SchemaEntry("geometric_intersection",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("geometric_item_specific_usage",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("geometric_model_element_relationship",&STEP::ObjectHelper<STEPGeometric_Model_Element_Relationship,0>::Construct )
,		SchemaEntry("representation_context",&STEP::ObjectHelper<STEPRepresentation_Context,2>::Construct )
,		SchemaEntry("geometric_representation_context",&STEP::ObjectHelper<STEPGeometric_Representation_Context,1>::Construct )
,		SchemaEntry("geometric_tolerance_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("geometric_tolerance_with_defined_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("geometrical_tolerance_callout",&STEP::ObjectHelper<STEPGeometrical_Tolerance_Callout,0>::Construct )
,		SchemaEntry("geometrically_bounded_2d_wireframe_representation",&STEP::ObjectHelper<STEPGeometrically_Bounded_2d_Wireframe_Representation,0>::Construct )
,		SchemaEntry("geometrically_bounded_surface_shape_representation",&STEP::ObjectHelper<STEPGeometrically_Bounded_Surface_Shape_Representation,0>::Construct )
,		SchemaEntry("geometrically_bounded_wireframe_shape_representation",&STEP::ObjectHelper<STEPGeometrically_Bounded_Wireframe_Shape_Representation,0>::Construct )
,		SchemaEntry("global_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("global_uncertainty_assigned_context",&STEP::ObjectHelper<STEPGlobal_Uncertainty_Assigned_Context,1>::Construct )
,		SchemaEntry("global_unit_assigned_context",&STEP::ObjectHelper<STEPGlobal_Unit_Assigned_Context,1>::Construct )
,		SchemaEntry("ground_fact",&STEP::ObjectHelper<STEPGround_Fact,0>::Construct )
,		SchemaEntry("group_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("hardness_representation",&STEP::ObjectHelper<STEPHardness_Representation,0>::Construct )
,		SchemaEntry("hidden_element_over_riding_styled_item",&STEP::ObjectHelper<STEPHidden_Element_Over_Riding_Styled_Item,0>::Construct )
,		SchemaEntry("hyperbola",&STEP::ObjectHelper<STEPHyperbola,2>::Construct )
,		SchemaEntry("id_attribute",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("identification_role",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("illuminance_measure_with_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("illuminance_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("included_text_block",&STEP::ObjectHelper<STEPIncluded_Text_Block,0>::Construct )
,		SchemaEntry("inclusion_product_concept_feature",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("user_selected_elements",&STEP::ObjectHelper<STEPUser_Selected_Elements,1>::Construct )
,		SchemaEntry("indirectly_selected_elements",&STEP::ObjectHelper<STEPIndirectly_Selected_Elements,1>::Construct )
,		SchemaEntry("user_selected_shape_elements",&STEP::ObjectHelper<STEPUser_Selected_Shape_Elements,0>::Construct )
,		SchemaEntry("indirectly_selected_shape_elements",&STEP::ObjectHelper<STEPIndirectly_Selected_Shape_Elements,0>::Construct )
,		SchemaEntry("inductance_measure_with_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("inductance_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("information_right",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("information_usage_right",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("instance_usage_context_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("shape_feature_definition",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("instanced_feature",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("simple_numeric_expression",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("literal_number",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("int_literal",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("integer_representation_item",&STEP::ObjectHelper<STEPInteger_Representation_Item,0>::Construct )
,		SchemaEntry("intersection_curve",&STEP::ObjectHelper<STEPIntersection_Curve,0>::Construct )
,		SchemaEntry("multiple_arity_generic_expression",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("interval_expression",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("iso4217_currency",&STEP::ObjectHelper<STEPIso4217_Currency,0>::Construct )
,		SchemaEntry("known_source",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("laid_defined_transformation",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("language",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("leader_curve",&STEP::ObjectHelper<STEPLeader_Curve,0>::Construct )
,		SchemaEntry("leader_directed_callout",&STEP::ObjectHelper<STEPLeader_Directed_Callout,0>::Construct )
,		SchemaEntry("leader_directed_dimension",&STEP::ObjectHelper<STEPLeader_Directed_Dimension,0>::Construct )
,		SchemaEntry("leader_terminator",&STEP::ObjectHelper<STEPLeader_Terminator,0>::Construct )
,		SchemaEntry("length_measure_with_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("length_unit",&STEP::ObjectHelper<STEPLength_Unit,0>::Construct )
,		SchemaEntry("light_source",&STEP::ObjectHelper<STEPLight_Source,1>::Construct )
,		SchemaEntry("light_source_ambient",&STEP::ObjectHelper<STEPLight_Source_Ambient,0>::Construct )
,		SchemaEntry("light_source_directional",&STEP::ObjectHelper<STEPLight_Source_Directional,1>::Construct )
,		SchemaEntry("light_source_positional",&STEP::ObjectHelper<STEPLight_Source_Positional,3>::Construct )
,		SchemaEntry("light_source_spot",&STEP::ObjectHelper<STEPLight_Source_Spot,6>::Construct )
,		SchemaEntry("limits_and_fits",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("line",&STEP::ObjectHelper<STEPLine,2>::Construct )
,		SchemaEntry("line_profile_tolerance",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("linear_dimension",&STEP::ObjectHelper<STEPLinear_Dimension,0>::Construct )
,		SchemaEntry("simple_clause",&STEP::ObjectHelper<STEPSimple_Clause,0>::Construct )
,		SchemaEntry("literal_conjunction",&STEP::ObjectHelper<STEPLiteral_Conjunction,0>::Construct )
,		SchemaEntry("literal_disjunction",&STEP::ObjectHelper<STEPLiteral_Disjunction,0>::Construct )
,		SchemaEntry("local_time",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("logical_literal",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("logical_representation_item",&STEP::ObjectHelper<STEPLogical_Representation_Item,0>::Construct )
,		SchemaEntry("loss_tangent_measure_with_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("lot_effectivity",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("luminous_flux_measure_with_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("luminous_flux_unit",&STEP::ObjectHelper<STEPLuminous_Flux_Unit,0>::Construct )
,		SchemaEntry("luminous_intensity_measure_with_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("luminous_intensity_unit",&STEP::ObjectHelper<STEPLuminous_Intensity_Unit,0>::Construct )
,		SchemaEntry("magnetic_flux_density_measure_with_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("magnetic_flux_density_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("magnetic_flux_measure_with_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("magnetic_flux_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("make_from_usage_option",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("manifold_subsurface_shape_representation",&STEP::ObjectHelper<STEPManifold_Subsurface_Shape_Representation,0>::Construct )
,		SchemaEntry("manifold_surface_shape_representation",&STEP::ObjectHelper<STEPManifold_Surface_Shape_Representation,0>::Construct )
,		SchemaEntry("mass_measure_with_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("mass_unit",&STEP::ObjectHelper<STEPMass_Unit,0>::Construct )
,		SchemaEntry("material_designation_characterization",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("material_property",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("material_property_representation",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("measure_qualification",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("measure_representation_item",&STEP::ObjectHelper<STEPMeasure_Representation_Item,0>::Construct )
,		SchemaEntry("product_context",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("mechanical_context",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("mechanical_design_and_draughting_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("mechanical_design_geometric_presentation_area",&STEP::ObjectHelper<STEPMechanical_Design_Geometric_Presentation_Area,0>::Construct )
,		SchemaEntry("mechanical_design_geometric_presentation_representation",&STEP::ObjectHelper<STEPMechanical_Design_Geometric_Presentation_Representation,0>::Construct )
,		SchemaEntry("mechanical_design_presentation_representation_with_draughting",&STEP::ObjectHelper<STEPMechanical_Design_Presentation_Representation_With_Draughting,0>::Construct )
,		SchemaEntry("mechanical_design_shaded_presentation_area",&STEP::ObjectHelper<STEPMechanical_Design_Shaded_Presentation_Area,0>::Construct )
,		SchemaEntry("mechanical_design_shaded_presentation_representation",&STEP::ObjectHelper<STEPMechanical_Design_Shaded_Presentation_Representation,0>::Construct )
,		SchemaEntry("min_and_major_ply_orientation_basis",&STEP::ObjectHelper<STEPMin_And_Major_Ply_Orientation_Basis,0>::Construct )
,		SchemaEntry("modified_geometric_tolerance",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("modified_solid_with_placed_configuration",&STEP::ObjectHelper<STEPModified_Solid_With_Placed_Configuration,1>::Construct )
,		SchemaEntry("moments_of_inertia_representation",&STEP::ObjectHelper<STEPMoments_Of_Inertia_Representation,0>::Construct )
,		SchemaEntry("multi_language_attribute_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("multiple_arity_boolean_expression",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("multiple_arity_numeric_expression",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("name_attribute",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("next_assembly_usage_occurrence",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("non_manifold_surface_shape_representation",&STEP::ObjectHelper<STEPNon_Manifold_Surface_Shape_Representation,0>::Construct )
,		SchemaEntry("null_representation_item",&STEP::ObjectHelper<STEPNull_Representation_Item,0>::Construct )
,		SchemaEntry("object_role",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("offset_curve_2d",&STEP::ObjectHelper<STEPOffset_Curve_2d,3>::Construct )
,		SchemaEntry("offset_curve_3d",&STEP::ObjectHelper<STEPOffset_Curve_3d,4>::Construct )
,		SchemaEntry("offset_surface",&STEP::ObjectHelper<STEPOffset_Surface,3>::Construct )
,		SchemaEntry("one_direction_repeat_factor",&STEP::ObjectHelper<STEPOne_Direction_Repeat_Factor,1>::Construct )
,		SchemaEntry("open_shell",&STEP::ObjectHelper<STEPOpen_Shell,0>::Construct )
,		SchemaEntry("ordinal_date",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("projection_directed_callout",&STEP::ObjectHelper<STEPProjection_Directed_Callout,0>::Construct )
,		SchemaEntry("ordinate_dimension",&STEP::ObjectHelper<STEPOrdinate_Dimension,0>::Construct )
,		SchemaEntry("organization",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("organization_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("organization_role",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("organizational_address",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("organizational_project",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("organizational_project_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("organizational_project_role",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("oriented_closed_shell",&STEP::ObjectHelper<STEPOriented_Closed_Shell,2>::Construct )
,		SchemaEntry("oriented_edge",&STEP::ObjectHelper<STEPOriented_Edge,2>::Construct )
,		SchemaEntry("oriented_face",&STEP::ObjectHelper<STEPOriented_Face,2>::Construct )
,		SchemaEntry("oriented_open_shell",&STEP::ObjectHelper<STEPOriented_Open_Shell,2>::Construct )
,		SchemaEntry("oriented_path",&STEP::ObjectHelper<STEPOriented_Path,2>::Construct )
,		SchemaEntry("oriented_surface",&STEP::ObjectHelper<STEPOriented_Surface,1>::Construct )
,		SchemaEntry("outer_boundary_curve",&STEP::ObjectHelper<STEPOuter_Boundary_Curve,0>::Construct )
,		SchemaEntry("package_product_concept_feature",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("parabola",&STEP::ObjectHelper<STEPParabola,1>::Construct )
,		SchemaEntry("parallel_offset",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("parallelism_tolerance",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("parametric_representation_context",&STEP::ObjectHelper<STEPParametric_Representation_Context,0>::Construct )
,		SchemaEntry("partial_document_with_structured_text_representation_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("percentage_laminate_definition",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("zone_structural_makeup",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("percentage_laminate_table",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("percentage_ply_definition",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("perpendicular_to",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("perpendicularity_tolerance",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("person",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("person_and_organization",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("personal_address",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("person_and_organization_address",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("person_and_organization_role",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("physical_breakdown_context",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("physical_element_usage",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("presentation_view",&STEP::ObjectHelper<STEPPresentation_View,0>::Construct )
,		SchemaEntry("picture_representation",&STEP::ObjectHelper<STEPPicture_Representation,0>::Construct )
,		SchemaEntry("placed_datum_target_feature",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("placed_feature",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("planar_extent",&STEP::ObjectHelper<STEPPlanar_Extent,2>::Construct )
,		SchemaEntry("planar_box",&STEP::ObjectHelper<STEPPlanar_Box,1>::Construct )
,		SchemaEntry("plane",&STEP::ObjectHelper<STEPPlane,0>::Construct )
,		SchemaEntry("plane_angle_measure_with_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("plane_angle_unit",&STEP::ObjectHelper<STEPPlane_Angle_Unit,0>::Construct )
,		SchemaEntry("plus_minus_tolerance",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("ply_laminate_definition",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("ply_laminate_sequence_definition",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("ply_laminate_table",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("point_and_vector",&STEP::ObjectHelper<STEPPoint_And_Vector,0>::Construct )
,		SchemaEntry("point_on_curve",&STEP::ObjectHelper<STEPPoint_On_Curve,2>::Construct )
,		SchemaEntry("point_on_surface",&STEP::ObjectHelper<STEPPoint_On_Surface,3>::Construct )
,		SchemaEntry("point_path",&STEP::ObjectHelper<STEPPoint_Path,0>::Construct )
,		SchemaEntry("point_replica",&STEP::ObjectHelper<STEPPoint_Replica,2>::Construct )
,		SchemaEntry("point_style",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("polar_complex_number_literal",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("poly_loop",&STEP::ObjectHelper<STEPPoly_Loop,1>::Construct )
,		SchemaEntry("polyline",&STEP::ObjectHelper<STEPPolyline,1>::Construct )
,		SchemaEntry("position_tolerance",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("positioned_sketch",&STEP::ObjectHelper<STEPPositioned_Sketch,2>::Construct )
,		SchemaEntry("power_measure_with_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("power_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("pre_defined_symbol",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("pre_defined_dimension_symbol",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("pre_defined_geometrical_tolerance_symbol",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("pre_defined_point_marker_symbol",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("pre_defined_surface_condition_symbol",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("pre_defined_surface_side_style",&STEP::ObjectHelper<STEPPre_Defined_Surface_Side_Style,0>::Construct )
,		SchemaEntry("pre_defined_terminator_symbol",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("pre_defined_tile",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("precision_qualifier",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("predefined_picture_representation_item",&STEP::ObjectHelper<STEPPredefined_Picture_Representation_Item,0>::Construct )
,		SchemaEntry("presentation_layer_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("presentation_size",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("presentation_style_assignment",&STEP::ObjectHelper<STEPPresentation_Style_Assignment,1>::Construct )
,		SchemaEntry("presentation_style_by_context",&STEP::ObjectHelper<STEPPresentation_Style_By_Context,1>::Construct )
,		SchemaEntry("presented_item_representation",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("pressure_measure_with_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("pressure_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("procedural_representation",&STEP::ObjectHelper<STEPProcedural_Representation,0>::Construct )
,		SchemaEntry("procedural_representation_sequence",&STEP::ObjectHelper<STEPProcedural_Representation_Sequence,3>::Construct )
,		SchemaEntry("procedural_shape_representation",&STEP::ObjectHelper<STEPProcedural_Shape_Representation,0>::Construct )
,		SchemaEntry("procedural_shape_representation_sequence",&STEP::ObjectHelper<STEPProcedural_Shape_Representation_Sequence,0>::Construct )
,		SchemaEntry("product",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("product_category",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("product_concept",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("product_class",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("product_concept_context",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("product_concept_feature_association",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("product_concept_feature_category_usage",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("product_concept_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("product_definition_context_association",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("product_definition_context_role",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("product_definition_formation",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("product_definition_formation_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("product_definition_formation_with_specified_source",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("product_definition_group_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("product_definition_occurrence_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("product_definition_shape",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("product_definition_substitute",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("product_definition_with_associated_documents",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("product_identification",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("product_material_composition_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("product_related_product_category",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("product_specification",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("tolerance_zone_definition",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("projected_zone_definition",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("projection_curve",&STEP::ObjectHelper<STEPProjection_Curve,0>::Construct )
,		SchemaEntry("promissory_usage_occurrence",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("property_definition_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("qualified_representation_item",&STEP::ObjectHelper<STEPQualified_Representation_Item,1>::Construct )
,		SchemaEntry("qualitative_uncertainty",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("quantified_assembly_component_usage",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("quasi_uniform_curve",&STEP::ObjectHelper<STEPQuasi_Uniform_Curve,0>::Construct )
,		SchemaEntry("quasi_uniform_surface",&STEP::ObjectHelper<STEPQuasi_Uniform_Surface,0>::Construct )
,		SchemaEntry("radioactivity_measure_with_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("radioactivity_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("radius_dimension",&STEP::ObjectHelper<STEPRadius_Dimension,0>::Construct )
,		SchemaEntry("range_characteristic",&STEP::ObjectHelper<STEPRange_Characteristic,0>::Construct )
,		SchemaEntry("ratio_unit",&STEP::ObjectHelper<STEPRatio_Unit,0>::Construct )
,		SchemaEntry("rational_b_spline_curve",&STEP::ObjectHelper<STEPRational_B_Spline_Curve,1>::Construct )
,		SchemaEntry("rational_b_spline_surface",&STEP::ObjectHelper<STEPRational_B_Spline_Surface,0>::Construct )
,		SchemaEntry("slash_expression",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("rational_representation_item",&STEP::ObjectHelper<STEPRational_Representation_Item,0>::Construct )
,		SchemaEntry("real_literal",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("real_representation_item",&STEP::ObjectHelper<STEPReal_Representation_Item,0>::Construct )
,		SchemaEntry("rectangular_composite_surface",&STEP::ObjectHelper<STEPRectangular_Composite_Surface,0>::Construct )
,		SchemaEntry("rectangular_trimmed_surface",&STEP::ObjectHelper<STEPRectangular_Trimmed_Surface,7>::Construct )
,		SchemaEntry("referenced_modified_datum",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("relative_event_occurrence",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("rep_item_group",&STEP::ObjectHelper<STEPRep_Item_Group,0>::Construct )
,		SchemaEntry("reparametrised_composite_curve_segment",&STEP::ObjectHelper<STEPReparametrised_Composite_Curve_Segment,1>::Construct )
,		SchemaEntry("representation_relationship_with_transformation",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("requirement_assigned_object",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("requirement_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("requirement_source",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("requirement_view_definition_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("resistance_measure_with_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("resistance_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("revolved_area_solid",&STEP::ObjectHelper<STEPRevolved_Area_Solid,2>::Construct )
,		SchemaEntry("revolved_face_solid",&STEP::ObjectHelper<STEPRevolved_Face_Solid,2>::Construct )
,		SchemaEntry("revolved_face_solid_with_trim_conditions",&STEP::ObjectHelper<STEPRevolved_Face_Solid_With_Trim_Conditions,2>::Construct )
,		SchemaEntry("right_angular_wedge",&STEP::ObjectHelper<STEPRight_Angular_Wedge,5>::Construct )
,		SchemaEntry("right_circular_cone",&STEP::ObjectHelper<STEPRight_Circular_Cone,4>::Construct )
,		SchemaEntry("right_circular_cylinder",&STEP::ObjectHelper<STEPRight_Circular_Cylinder,3>::Construct )
,		SchemaEntry("right_to_usage_association",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("role_association",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("roundness_tolerance",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("row_representation_item",&STEP::ObjectHelper<STEPRow_Representation_Item,0>::Construct )
,		SchemaEntry("row_value",&STEP::ObjectHelper<STEPRow_Value,0>::Construct )
,		SchemaEntry("row_variable",&STEP::ObjectHelper<STEPRow_Variable,0>::Construct )
,		SchemaEntry("rule_action",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("rule_condition",&STEP::ObjectHelper<STEPRule_Condition,0>::Construct )
,		SchemaEntry("rule_set",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("rule_set_group",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("rule_superseded_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("rule_supersedence",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("surface_curve_swept_area_solid",&STEP::ObjectHelper<STEPSurface_Curve_Swept_Area_Solid,4>::Construct )
,		SchemaEntry("ruled_surface_swept_area_solid",&STEP::ObjectHelper<STEPRuled_Surface_Swept_Area_Solid,0>::Construct )
,		SchemaEntry("runout_zone_definition",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("runout_zone_orientation",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("runout_zone_orientation_reference_direction",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("satisfied_requirement",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("satisfies_requirement",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("satisfying_item",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("scalar_variable",&STEP::ObjectHelper<STEPScalar_Variable,0>::Construct )
,		SchemaEntry("scattering_parameter",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("sculptured_solid",&STEP::ObjectHelper<STEPSculptured_Solid,2>::Construct )
,		SchemaEntry("seam_curve",&STEP::ObjectHelper<STEPSeam_Curve,0>::Construct )
,		SchemaEntry("security_classification",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("security_classification_level",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("serial_numbered_effectivity",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("shape_aspect_associativity",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("shape_aspect_deriving_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("shape_definition_representation",&STEP::ObjectHelper<STEPShape_Definition_Representation,0>::Construct )
,		SchemaEntry("shape_dimension_representation",&STEP::ObjectHelper<STEPShape_Dimension_Representation,0>::Construct )
,		SchemaEntry("shape_representation_with_parameters",&STEP::ObjectHelper<STEPShape_Representation_With_Parameters,0>::Construct )
,		SchemaEntry("shell_based_surface_model",&STEP::ObjectHelper<STEPShell_Based_Surface_Model,1>::Construct )
,		SchemaEntry("shell_based_wireframe_model",&STEP::ObjectHelper<STEPShell_Based_Wireframe_Model,1>::Construct )
,		SchemaEntry("shell_based_wireframe_shape_representation",&STEP::ObjectHelper<STEPShell_Based_Wireframe_Shape_Representation,0>::Construct )
,		SchemaEntry("si_unit",&STEP::ObjectHelper<STEPSi_Unit,2>::Construct )
,		SchemaEntry("si_absorbed_dose_unit",&STEP::ObjectHelper<STEPSi_Absorbed_Dose_Unit,0>::Construct )
,		SchemaEntry("si_capacitance_unit",&STEP::ObjectHelper<STEPSi_Capacitance_Unit,0>::Construct )
,		SchemaEntry("si_conductance_unit",&STEP::ObjectHelper<STEPSi_Conductance_Unit,0>::Construct )
,		SchemaEntry("si_dose_equivalent_unit",&STEP::ObjectHelper<STEPSi_Dose_Equivalent_Unit,0>::Construct )
,		SchemaEntry("si_electric_charge_unit",&STEP::ObjectHelper<STEPSi_Electric_Charge_Unit,0>::Construct )
,		SchemaEntry("si_electric_potential_unit",&STEP::ObjectHelper<STEPSi_Electric_Potential_Unit,0>::Construct )
,		SchemaEntry("si_energy_unit",&STEP::ObjectHelper<STEPSi_Energy_Unit,0>::Construct )
,		SchemaEntry("si_force_unit",&STEP::ObjectHelper<STEPSi_Force_Unit,0>::Construct )
,		SchemaEntry("si_frequency_unit",&STEP::ObjectHelper<STEPSi_Frequency_Unit,0>::Construct )
,		SchemaEntry("si_illuminance_unit",&STEP::ObjectHelper<STEPSi_Illuminance_Unit,0>::Construct )
,		SchemaEntry("si_inductance_unit",&STEP::ObjectHelper<STEPSi_Inductance_Unit,0>::Construct )
,		SchemaEntry("si_magnetic_flux_density_unit",&STEP::ObjectHelper<STEPSi_Magnetic_Flux_Density_Unit,0>::Construct )
,		SchemaEntry("si_magnetic_flux_unit",&STEP::ObjectHelper<STEPSi_Magnetic_Flux_Unit,0>::Construct )
,		SchemaEntry("si_power_unit",&STEP::ObjectHelper<STEPSi_Power_Unit,0>::Construct )
,		SchemaEntry("si_pressure_unit",&STEP::ObjectHelper<STEPSi_Pressure_Unit,0>::Construct )
,		SchemaEntry("si_radioactivity_unit",&STEP::ObjectHelper<STEPSi_Radioactivity_Unit,0>::Construct )
,		SchemaEntry("si_resistance_unit",&STEP::ObjectHelper<STEPSi_Resistance_Unit,0>::Construct )
,		SchemaEntry("smeared_material_definition",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("solid_angle_measure_with_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("solid_angle_unit",&STEP::ObjectHelper<STEPSolid_Angle_Unit,0>::Construct )
,		SchemaEntry("solid_curve_font",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("solid_replica",&STEP::ObjectHelper<STEPSolid_Replica,2>::Construct )
,		SchemaEntry("solid_with_chamfered_edges",&STEP::ObjectHelper<STEPSolid_With_Chamfered_Edges,0>::Construct )
,		SchemaEntry("solid_with_angle_based_chamfer",&STEP::ObjectHelper<STEPSolid_With_Angle_Based_Chamfer,3>::Construct )
,		SchemaEntry("solid_with_shape_element_pattern",&STEP::ObjectHelper<STEPSolid_With_Shape_Element_Pattern,1>::Construct )
,		SchemaEntry("solid_with_circular_pattern",&STEP::ObjectHelper<STEPSolid_With_Circular_Pattern,4>::Construct )
,		SchemaEntry("solid_with_depression",&STEP::ObjectHelper<STEPSolid_With_Depression,1>::Construct )
,		SchemaEntry("solid_with_pocket",&STEP::ObjectHelper<STEPSolid_With_Pocket,2>::Construct )
,		SchemaEntry("solid_with_circular_pocket",&STEP::ObjectHelper<STEPSolid_With_Circular_Pocket,1>::Construct )
,		SchemaEntry("solid_with_protrusion",&STEP::ObjectHelper<STEPSolid_With_Protrusion,2>::Construct )
,		SchemaEntry("solid_with_circular_protrusion",&STEP::ObjectHelper<STEPSolid_With_Circular_Protrusion,1>::Construct )
,		SchemaEntry("solid_with_hole",&STEP::ObjectHelper<STEPSolid_With_Hole,0>::Construct )
,		SchemaEntry("solid_with_stepped_round_hole",&STEP::ObjectHelper<STEPSolid_With_Stepped_Round_Hole,1>::Construct )
,		SchemaEntry("solid_with_conical_bottom_round_hole",&STEP::ObjectHelper<STEPSolid_With_Conical_Bottom_Round_Hole,2>::Construct )
,		SchemaEntry("solid_with_constant_radius_edge_blend",&STEP::ObjectHelper<STEPSolid_With_Constant_Radius_Edge_Blend,1>::Construct )
,		SchemaEntry("solid_with_slot",&STEP::ObjectHelper<STEPSolid_With_Slot,2>::Construct )
,		SchemaEntry("solid_with_curved_slot",&STEP::ObjectHelper<STEPSolid_With_Curved_Slot,1>::Construct )
,		SchemaEntry("solid_with_double_offset_chamfer",&STEP::ObjectHelper<STEPSolid_With_Double_Offset_Chamfer,2>::Construct )
,		SchemaEntry("solid_with_flat_bottom_round_hole",&STEP::ObjectHelper<STEPSolid_With_Flat_Bottom_Round_Hole,1>::Construct )
,		SchemaEntry("solid_with_general_pocket",&STEP::ObjectHelper<STEPSolid_With_General_Pocket,2>::Construct )
,		SchemaEntry("solid_with_general_protrusion",&STEP::ObjectHelper<STEPSolid_With_General_Protrusion,2>::Construct )
,		SchemaEntry("solid_with_groove",&STEP::ObjectHelper<STEPSolid_With_Groove,5>::Construct )
,		SchemaEntry("solid_with_incomplete_circular_pattern",&STEP::ObjectHelper<STEPSolid_With_Incomplete_Circular_Pattern,1>::Construct )
,		SchemaEntry("solid_with_rectangular_pattern",&STEP::ObjectHelper<STEPSolid_With_Rectangular_Pattern,4>::Construct )
,		SchemaEntry("solid_with_incomplete_rectangular_pattern",&STEP::ObjectHelper<STEPSolid_With_Incomplete_Rectangular_Pattern,0>::Construct )
,		SchemaEntry("solid_with_rectangular_pocket",&STEP::ObjectHelper<STEPSolid_With_Rectangular_Pocket,3>::Construct )
,		SchemaEntry("solid_with_rectangular_protrusion",&STEP::ObjectHelper<STEPSolid_With_Rectangular_Protrusion,3>::Construct )
,		SchemaEntry("solid_with_single_offset_chamfer",&STEP::ObjectHelper<STEPSolid_With_Single_Offset_Chamfer,1>::Construct )
,		SchemaEntry("solid_with_spherical_bottom_round_hole",&STEP::ObjectHelper<STEPSolid_With_Spherical_Bottom_Round_Hole,1>::Construct )
,		SchemaEntry("solid_with_stepped_round_hole_and_conical_transitions",&STEP::ObjectHelper<STEPSolid_With_Stepped_Round_Hole_And_Conical_Transitions,1>::Construct )
,		SchemaEntry("solid_with_straight_slot",&STEP::ObjectHelper<STEPSolid_With_Straight_Slot,1>::Construct )
,		SchemaEntry("solid_with_tee_section_slot",&STEP::ObjectHelper<STEPSolid_With_Tee_Section_Slot,2>::Construct )
,		SchemaEntry("solid_with_through_depression",&STEP::ObjectHelper<STEPSolid_With_Through_Depression,1>::Construct )
,		SchemaEntry("solid_with_trapezoidal_section_slot",&STEP::ObjectHelper<STEPSolid_With_Trapezoidal_Section_Slot,2>::Construct )
,		SchemaEntry("track_blended_solid",&STEP::ObjectHelper<STEPTrack_Blended_Solid,0>::Construct )
,		SchemaEntry("solid_with_variable_radius_edge_blend",&STEP::ObjectHelper<STEPSolid_With_Variable_Radius_Edge_Blend,3>::Construct )
,		SchemaEntry("source_for_requirement",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("sourced_requirement",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("specification_definition",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("specified_higher_usage_occurrence",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("sphere",&STEP::ObjectHelper<STEPSphere,2>::Construct )
,		SchemaEntry("spherical_surface",&STEP::ObjectHelper<STEPSpherical_Surface,1>::Construct )
,		SchemaEntry("start_request",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("start_work",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("straightness_tolerance",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("structured_dimension_callout",&STEP::ObjectHelper<STEPStructured_Dimension_Callout,0>::Construct )
,		SchemaEntry("structured_text_composition",&STEP::ObjectHelper<STEPStructured_Text_Composition,0>::Construct )
,		SchemaEntry("structured_text_representation",&STEP::ObjectHelper<STEPStructured_Text_Representation,0>::Construct )
,		SchemaEntry("subedge",&STEP::ObjectHelper<STEPSubedge,1>::Construct )
,		SchemaEntry("subface",&STEP::ObjectHelper<STEPSubface,1>::Construct )
,		SchemaEntry("supplied_part_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("surface_condition_callout",&STEP::ObjectHelper<STEPSurface_Condition_Callout,0>::Construct )
,		SchemaEntry("swept_surface",&STEP::ObjectHelper<STEPSwept_Surface,1>::Construct )
,		SchemaEntry("surface_of_linear_extrusion",&STEP::ObjectHelper<STEPSurface_Of_Linear_Extrusion,1>::Construct )
,		SchemaEntry("surface_of_revolution",&STEP::ObjectHelper<STEPSurface_Of_Revolution,1>::Construct )
,		SchemaEntry("surface_patch",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("surface_profile_tolerance",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("surface_rendering_properties",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("surface_replica",&STEP::ObjectHelper<STEPSurface_Replica,2>::Construct )
,		SchemaEntry("surface_side_style",&STEP::ObjectHelper<STEPSurface_Side_Style,2>::Construct )
,		SchemaEntry("surface_style_boundary",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("surface_style_control_grid",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("surface_style_fill_area",&STEP::ObjectHelper<STEPSurface_Style_Fill_Area,1>::Construct )
,		SchemaEntry("surface_style_parameter_line",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("surface_style_reflectance_ambient",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("surface_style_reflectance_ambient_diffuse",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("surface_style_reflectance_ambient_diffuse_specular",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("surface_style_rendering",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("surface_style_rendering_with_properties",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("surface_style_segmentation_curve",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("surface_style_silhouette",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("surface_style_transparent",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("surface_style_usage",&STEP::ObjectHelper<STEPSurface_Style_Usage,2>::Construct )
,		SchemaEntry("surface_texture_representation",&STEP::ObjectHelper<STEPSurface_Texture_Representation,0>::Construct )
,		SchemaEntry("surfaced_open_shell",&STEP::ObjectHelper<STEPSurfaced_Open_Shell,0>::Construct )
,		SchemaEntry("swept_disk_solid",&STEP::ObjectHelper<STEPSwept_Disk_Solid,5>::Construct )
,		SchemaEntry("symbol",&STEP::ObjectHelper<STEPSymbol,0>::Construct )
,		SchemaEntry("symbol_colour",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("symbol_representation_map",&STEP::ObjectHelper<STEPSymbol_Representation_Map,0>::Construct )
,		SchemaEntry("symbol_style",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("symbol_target",&STEP::ObjectHelper<STEPSymbol_Target,3>::Construct )
,		SchemaEntry("symmetric_shape_aspect",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("symmetry_tolerance",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("table_representation_item",&STEP::ObjectHelper<STEPTable_Representation_Item,0>::Construct )
,		SchemaEntry("tactile_appearance_representation",&STEP::ObjectHelper<STEPTactile_Appearance_Representation,0>::Construct )
,		SchemaEntry("tagged_text_format",&STEP::ObjectHelper<STEPTagged_Text_Format,0>::Construct )
,		SchemaEntry("tagged_text_item",&STEP::ObjectHelper<STEPTagged_Text_Item,0>::Construct )
,		SchemaEntry("tangent",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("text_font",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("text_font_family",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("text_font_in_family",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("text_literal_with_associated_curves",&STEP::ObjectHelper<STEPText_Literal_With_Associated_Curves,1>::Construct )
,		SchemaEntry("text_literal_with_blanking_box",&STEP::ObjectHelper<STEPText_Literal_With_Blanking_Box,1>::Construct )
,		SchemaEntry("text_literal_with_extent",&STEP::ObjectHelper<STEPText_Literal_With_Extent,1>::Construct )
,		SchemaEntry("text_string_representation",&STEP::ObjectHelper<STEPText_String_Representation,0>::Construct )
,		SchemaEntry("text_style",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("text_style_for_defined_font",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("text_style_with_box_characteristics",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("text_style_with_mirror",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("text_style_with_spacing",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("thermal_resistance_measure_with_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("thermal_resistance_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("thermodynamic_temperature_measure_with_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("thermodynamic_temperature_unit",&STEP::ObjectHelper<STEPThermodynamic_Temperature_Unit,0>::Construct )
,		SchemaEntry("thickened_face_solid",&STEP::ObjectHelper<STEPThickened_Face_Solid,3>::Construct )
,		SchemaEntry("thickness_laminate_definition",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("thickness_laminate_table",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("time_interval",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("time_interval_based_effectivity",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("time_interval_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("time_interval_role",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("time_interval_with_bounds",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("time_measure_with_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("time_unit",&STEP::ObjectHelper<STEPTime_Unit,0>::Construct )
,		SchemaEntry("tolerance_value",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("tolerance_zone",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("tolerance_zone_form",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("torus",&STEP::ObjectHelper<STEPTorus,3>::Construct )
,		SchemaEntry("total_runout_tolerance",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("track_blended_solid_with_end_conditions",&STEP::ObjectHelper<STEPTrack_Blended_Solid_With_End_Conditions,1>::Construct )
,		SchemaEntry("trimmed_curve",&STEP::ObjectHelper<STEPTrimmed_Curve,5>::Construct )
,		SchemaEntry("two_direction_repeat_factor",&STEP::ObjectHelper<STEPTwo_Direction_Repeat_Factor,1>::Construct )
,		SchemaEntry("type_qualifier",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("unary_generic_expression",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("unary_numeric_expression",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("uncertainty_assigned_representation",&STEP::ObjectHelper<STEPUncertainty_Assigned_Representation,1>::Construct )
,		SchemaEntry("uncertainty_measure_with_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("uniform_curve",&STEP::ObjectHelper<STEPUniform_Curve,0>::Construct )
,		SchemaEntry("uniform_resource_identifier",&STEP::ObjectHelper<STEPUniform_Resource_Identifier,0>::Construct )
,		SchemaEntry("uniform_surface",&STEP::ObjectHelper<STEPUniform_Surface,0>::Construct )
,		SchemaEntry("usage_association",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("user_defined_curve_font",&STEP::ObjectHelper<STEPUser_Defined_Curve_Font,0>::Construct )
,		SchemaEntry("user_defined_marker",&STEP::ObjectHelper<STEPUser_Defined_Marker,0>::Construct )
,		SchemaEntry("user_defined_terminator_symbol",&STEP::ObjectHelper<STEPUser_Defined_Terminator_Symbol,0>::Construct )
,		SchemaEntry("value_range",&STEP::ObjectHelper<STEPValue_Range,0>::Construct )
,		SchemaEntry("value_representation_item",&STEP::ObjectHelper<STEPValue_Representation_Item,1>::Construct )
,		SchemaEntry("vector",&STEP::ObjectHelper<STEPVector,2>::Construct )
,		SchemaEntry("vector_style",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("velocity_measure_with_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("velocity_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("versioned_action_request",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("vertex",&STEP::ObjectHelper<STEPVertex,0>::Construct )
,		SchemaEntry("vertex_loop",&STEP::ObjectHelper<STEPVertex_Loop,1>::Construct )
,		SchemaEntry("vertex_point",&STEP::ObjectHelper<STEPVertex_Point,1>::Construct )
,		SchemaEntry("vertex_shell",&STEP::ObjectHelper<STEPVertex_Shell,1>::Construct )
,		SchemaEntry("view_volume",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("visual_appearance_representation",&STEP::ObjectHelper<STEPVisual_Appearance_Representation,0>::Construct )
,		SchemaEntry("volume_measure_with_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("volume_unit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("week_of_year_and_day_date",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("wire_shell",&STEP::ObjectHelper<STEPWire_Shell,1>::Construct )
,		SchemaEntry("year_month",&STEP::ObjectHelper<NotImplemented,0>::Construct )

	};
}

// -----------------------------------------------------------------------------------------------------------
void STEP::GetSchema(EXPRESS::ConversionSchema& out)
{
	out = EXPRESS::ConversionSchema(schema_raw);
}

namespace STEP {

// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<NotImplemented>(const STEP::DB& db, const LIST& params, NotImplemented* in)
{
	return 0;
}



// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPRepresentation_Item>(const DB& db, const LIST& params, STEPRepresentation_Item* in)
{
	size_t base = 0;
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to STEPRepresentation_Item"); }    do { // convert the 'STEPName' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::STEP::STEPRepresentation_Item,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->Name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to STEPRepresentation_Item to be a `label`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPRepresentation>(const DB& db, const LIST& params, STEPRepresentation* in)
{
	size_t base = 0;
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to STEPRepresentation"); }    do { // convert the 'STEPName' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::STEP::STEPRepresentation,3>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->Name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to STEPRepresentation to be a `label`")); }
    } while(0);
    do { // convert the 'STEPItems' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::STEP::STEPRepresentation,3>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->Items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to STEPRepresentation to be a `SET [1:?] OF representation_item`")); }
    } while(0);
    do { // convert the 'STEPContext_Of_Items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::STEP::STEPRepresentation,3>::aux_is_derived[2]=true; break; }
        try { GenericConvert( in->ContextOfItems, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to STEPRepresentation to be a `representation_context`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPProperty_Definition_Representation>(const DB& db, const LIST& params, STEPProperty_Definition_Representation* in)
{
	size_t base = 0;
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to STEPProperty_Definition_Representation"); }    do { // convert the 'STEPDefinition' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::STEP::STEPProperty_Definition_Representation,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->Definition, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to STEPProperty_Definition_Representation to be a `represented_definition`")); }
    } while(0);
    do { // convert the 'STEPUsed_Representation' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::STEP::STEPProperty_Definition_Representation,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->UsedRepresentation, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to STEPProperty_Definition_Representation to be a `representation`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPAbstract_Variable>(const DB& db, const LIST& params, STEPAbstract_Variable* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPProperty_Definition*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPShape_Representation>(const DB& db, const LIST& params, STEPShape_Representation* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPAdvanced_Brep_Shape_Representation>(const DB& db, const LIST& params, STEPAdvanced_Brep_Shape_Representation* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPShape_Representation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPTopological_Representation_Item>(const DB& db, const LIST& params, STEPTopological_Representation_Item* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation_Item*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to STEPTopological_Representation_Item"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPGeometric_Representation_Item>(const DB& db, const LIST& params, STEPGeometric_Representation_Item* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation_Item*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to STEPGeometric_Representation_Item"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPFace>(const DB& db, const LIST& params, STEPFace* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPTopological_Representation_Item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to STEPFace"); }    do { // convert the 'STEPBounds' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::STEP::STEPFace,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->Bounds, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to STEPFace to be a `SET [1:?] OF face_bound`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPFace_Surface>(const DB& db, const LIST& params, STEPFace_Surface* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPFace*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to STEPFace_Surface"); }    do { // convert the 'STEPFace_Geometry' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::STEP::STEPFace_Surface,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->FaceGeometry, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to STEPFace_Surface to be a `surface`")); }
    } while(0);
    do { // convert the 'STEPSame_Sense' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::STEP::STEPFace_Surface,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->SameSense, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to STEPFace_Surface to be a `BOOLEAN`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPAdvanced_Face>(const DB& db, const LIST& params, STEPAdvanced_Face* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPFace_Surface*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to STEPAdvanced_Face"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPNamed_Unit>(const DB& db, const LIST& params, STEPNamed_Unit* in)
{
	size_t base = 0;
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to STEPNamed_Unit"); }    do { // convert the 'STEPDimensions' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::STEP::STEPNamed_Unit,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->Dimensions, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to STEPNamed_Unit to be a `dimensional_exponents`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPAmount_Of_Substance_Unit>(const DB& db, const LIST& params, STEPAmount_Of_Substance_Unit* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPNamed_Unit*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPAngle_Direction_Reference>(const DB& db, const LIST& params, STEPAngle_Direction_Reference* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation_Item_Relationship*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPDraughting_Callout>(const DB& db, const LIST& params, STEPDraughting_Callout* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPDimension_Curve_Directed_Callout>(const DB& db, const LIST& params, STEPDimension_Curve_Directed_Callout* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPDraughting_Callout*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPAngular_Dimension>(const DB& db, const LIST& params, STEPAngular_Dimension* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPDimension_Curve_Directed_Callout*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPStyled_Item>(const DB& db, const LIST& params, STEPStyled_Item* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation_Item*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to STEPStyled_Item"); }    do { // convert the 'STEPStyles' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::STEP::STEPStyled_Item,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->Styles, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to STEPStyled_Item to be a `SET [1:?] OF presentation_style_assignment`")); }
    } while(0);
    do { // convert the 'STEPItem' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::STEP::STEPStyled_Item,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->Item, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to STEPStyled_Item to be a `representation_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPAnnotation_Occurrence>(const DB& db, const LIST& params, STEPAnnotation_Occurrence* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPStyled_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPAnnotation_Curve_Occurrence>(const DB& db, const LIST& params, STEPAnnotation_Curve_Occurrence* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPAnnotation_Occurrence*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPAnnotation_Fill_Area>(const DB& db, const LIST& params, STEPAnnotation_Fill_Area* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPAnnotation_Fill_Area_Occurrence>(const DB& db, const LIST& params, STEPAnnotation_Fill_Area_Occurrence* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPAnnotation_Occurrence*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPAnnotation_Plane>(const DB& db, const LIST& params, STEPAnnotation_Plane* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPAnnotation_Occurrence*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPAnnotation_Symbol_Occurrence>(const DB& db, const LIST& params, STEPAnnotation_Symbol_Occurrence* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPAnnotation_Occurrence*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPAnnotation_Subfigure_Occurrence>(const DB& db, const LIST& params, STEPAnnotation_Subfigure_Occurrence* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPAnnotation_Symbol_Occurrence*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPMapped_Item>(const DB& db, const LIST& params, STEPMapped_Item* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation_Item*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to STEPMapped_Item"); }    do { // convert the 'STEPMapping_Source' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::STEP::STEPMapped_Item,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->MappingSource, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to STEPMapped_Item to be a `representation_map`")); }
    } while(0);
    do { // convert the 'STEPMapping_Target' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::STEP::STEPMapped_Item,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->MappingTarget, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to STEPMapped_Item to be a `representation_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPAnnotation_Symbol>(const DB& db, const LIST& params, STEPAnnotation_Symbol* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPMapped_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPAnnotation_Text>(const DB& db, const LIST& params, STEPAnnotation_Text* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPMapped_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPAnnotation_Text_Character>(const DB& db, const LIST& params, STEPAnnotation_Text_Character* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPMapped_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPAnnotation_Text_Occurrence>(const DB& db, const LIST& params, STEPAnnotation_Text_Occurrence* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPAnnotation_Occurrence*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPCompound_Representation_Item>(const DB& db, const LIST& params, STEPCompound_Representation_Item* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPAtomic_Formula>(const DB& db, const LIST& params, STEPAtomic_Formula* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPCompound_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPAttribute_Assertion>(const DB& db, const LIST& params, STEPAttribute_Assertion* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPFact_Type*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPVariational_Representation_Item>(const DB& db, const LIST& params, STEPVariational_Representation_Item* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPAuxiliary_Geometric_Representation_Item>(const DB& db, const LIST& params, STEPAuxiliary_Geometric_Representation_Item* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPPlacement>(const DB& db, const LIST& params, STEPPlacement* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPAxis1_Placement>(const DB& db, const LIST& params, STEPAxis1_Placement* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPPlacement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPAxis2_Placement_2d>(const DB& db, const LIST& params, STEPAxis2_Placement_2d* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPPlacement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPAxis2_Placement_3d>(const DB& db, const LIST& params, STEPAxis2_Placement_3d* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPPlacement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPCurve>(const DB& db, const LIST& params, STEPCurve* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Representation_Item*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to STEPCurve"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPBounded_Curve>(const DB& db, const LIST& params, STEPBounded_Curve* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPCurve*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to STEPBounded_Curve"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPB_Spline_Curve>(const DB& db, const LIST& params, STEPB_Spline_Curve* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPBounded_Curve*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPB_Spline_Curve_With_Knots>(const DB& db, const LIST& params, STEPB_Spline_Curve_With_Knots* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPB_Spline_Curve*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSurface>(const DB& db, const LIST& params, STEPSurface* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Representation_Item*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to STEPSurface"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPBounded_Surface>(const DB& db, const LIST& params, STEPBounded_Surface* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSurface*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPB_Spline_Surface>(const DB& db, const LIST& params, STEPB_Spline_Surface* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPBounded_Surface*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPB_Spline_Surface_With_Knots>(const DB& db, const LIST& params, STEPB_Spline_Surface_With_Knots* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPB_Spline_Surface*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPBack_Chaining_Rule_Body>(const DB& db, const LIST& params, STEPBack_Chaining_Rule_Body* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPProperty_Definition*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPColour>(const DB& db, const LIST& params, STEPColour* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPBeveled_Sheet_Representation>(const DB& db, const LIST& params, STEPBeveled_Sheet_Representation* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPShape_Representation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPBezier_Curve>(const DB& db, const LIST& params, STEPBezier_Curve* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPB_Spline_Curve*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPBezier_Surface>(const DB& db, const LIST& params, STEPBezier_Surface* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPB_Spline_Surface*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPBinary_Representation_Item>(const DB& db, const LIST& params, STEPBinary_Representation_Item* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPBlock>(const DB& db, const LIST& params, STEPBlock* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPBoolean_Representation_Item>(const DB& db, const LIST& params, STEPBoolean_Representation_Item* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPBoolean_Result>(const DB& db, const LIST& params, STEPBoolean_Result* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Representation_Item*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to STEPBoolean_Result"); }    do { // convert the 'STEPOperator' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Operator, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to STEPBoolean_Result to be a `boolean_operator`")); }
    } while(0);
    do { // convert the 'STEPFirst_Operand' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->FirstOperand, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to STEPBoolean_Result to be a `boolean_operand`")); }
    } while(0);
    do { // convert the 'STEPSecond_Operand' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->SecondOperand, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to STEPBoolean_Result to be a `boolean_operand`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPComposite_Curve>(const DB& db, const LIST& params, STEPComposite_Curve* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPBounded_Curve*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to STEPComposite_Curve"); }    do { // convert the 'STEPSegments' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::STEP::STEPComposite_Curve,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->Segments, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to STEPComposite_Curve to be a `LIST [1:?] OF composite_curve_segment`")); }
    } while(0);
    do { // convert the 'STEPSelf_Intersect' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::STEP::STEPComposite_Curve,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->SelfIntersect, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to STEPComposite_Curve to be a `LOGICAL`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPComposite_Curve_On_Surface>(const DB& db, const LIST& params, STEPComposite_Curve_On_Surface* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPComposite_Curve*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPBoundary_Curve>(const DB& db, const LIST& params, STEPBoundary_Curve* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPComposite_Curve_On_Surface*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPPcurve>(const DB& db, const LIST& params, STEPPcurve* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPCurve*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPBounded_Pcurve>(const DB& db, const LIST& params, STEPBounded_Pcurve* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPPcurve*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSurface_Curve>(const DB& db, const LIST& params, STEPSurface_Curve* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPCurve*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPBounded_Surface_Curve>(const DB& db, const LIST& params, STEPBounded_Surface_Curve* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSurface_Curve*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPFounded_Item>(const DB& db, const LIST& params, STEPFounded_Item* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPHalf_Space_Solid>(const DB& db, const LIST& params, STEPHalf_Space_Solid* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPBoxed_Half_Space>(const DB& db, const LIST& params, STEPBoxed_Half_Space* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPHalf_Space_Solid*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSolid_Model>(const DB& db, const LIST& params, STEPSolid_Model* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Representation_Item*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to STEPSolid_Model"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPManifold_Solid_Brep>(const DB& db, const LIST& params, STEPManifold_Solid_Brep* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSolid_Model*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to STEPManifold_Solid_Brep"); }    do { // convert the 'STEPOuter' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::STEP::STEPManifold_Solid_Brep,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->Outer, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to STEPManifold_Solid_Brep to be a `closed_shell`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPBrep_With_Voids>(const DB& db, const LIST& params, STEPBrep_With_Voids* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPManifold_Solid_Brep*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPBytes_Representation_Item>(const DB& db, const LIST& params, STEPBytes_Representation_Item* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPBinary_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPCamera_Image>(const DB& db, const LIST& params, STEPCamera_Image* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPMapped_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPCamera_Image_3d_With_Scale>(const DB& db, const LIST& params, STEPCamera_Image_3d_With_Scale* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPCamera_Image*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPCamera_Model>(const DB& db, const LIST& params, STEPCamera_Model* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPCamera_Model_D3>(const DB& db, const LIST& params, STEPCamera_Model_D3* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPCamera_Model*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPCamera_Model_D3_Multi_Clipping>(const DB& db, const LIST& params, STEPCamera_Model_D3_Multi_Clipping* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPCamera_Model_D3*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPCamera_Model_D3_Multi_Clipping_Intersection>(const DB& db, const LIST& params, STEPCamera_Model_D3_Multi_Clipping_Intersection* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPCamera_Model_D3_Multi_Clipping_Union>(const DB& db, const LIST& params, STEPCamera_Model_D3_Multi_Clipping_Union* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPCamera_Model_D3_With_Hlhsr>(const DB& db, const LIST& params, STEPCamera_Model_D3_With_Hlhsr* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPCamera_Model_D3*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPCamera_Model_With_Light_Sources>(const DB& db, const LIST& params, STEPCamera_Model_With_Light_Sources* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPCamera_Model_D3*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPRepresentation_Map>(const DB& db, const LIST& params, STEPRepresentation_Map* in)
{
	size_t base = 0;
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to STEPRepresentation_Map"); }    do { // convert the 'STEPMapping_Origin' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::STEP::STEPRepresentation_Map,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->MappingOrigin, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to STEPRepresentation_Map to be a `representation_item`")); }
    } while(0);
    do { // convert the 'STEPMapped_Representation' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::STEP::STEPRepresentation_Map,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->MappedRepresentation, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to STEPRepresentation_Map to be a `representation`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPCamera_Usage>(const DB& db, const LIST& params, STEPCamera_Usage* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation_Map*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPPoint>(const DB& db, const LIST& params, STEPPoint* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Representation_Item*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to STEPPoint"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPCartesian_Point>(const DB& db, const LIST& params, STEPCartesian_Point* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPPoint*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to STEPCartesian_Point"); }    do { // convert the 'STEPCoordinates' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Coordinates, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to STEPCartesian_Point to be a `LIST [1:3] OF length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPFunctionally_Defined_Transformation>(const DB& db, const LIST& params, STEPFunctionally_Defined_Transformation* in)
{
	size_t base = 0;
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to STEPFunctionally_Defined_Transformation"); }    do { // convert the 'STEPName' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::STEP::STEPFunctionally_Defined_Transformation,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->Name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to STEPFunctionally_Defined_Transformation to be a `label`")); }
    } while(0);
    do { // convert the 'STEPDescription' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::STEP::STEPFunctionally_Defined_Transformation,2>::aux_is_derived[1]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->Description, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to STEPFunctionally_Defined_Transformation to be a `text`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPCartesian_Transformation_Operator>(const DB& db, const LIST& params, STEPCartesian_Transformation_Operator* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Representation_Item*>(in));
	if (params.GetSize() < 7) { throw STEP::TypeError("expected 7 arguments to STEPCartesian_Transformation_Operator"); }    do { // convert the 'STEPAxis1' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::STEP::STEPCartesian_Transformation_Operator,4>::aux_is_derived[0]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->Axis1, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to STEPCartesian_Transformation_Operator to be a `direction`")); }
    } while(0);
    do { // convert the 'STEPAxis2' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::STEP::STEPCartesian_Transformation_Operator,4>::aux_is_derived[1]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->Axis2, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to STEPCartesian_Transformation_Operator to be a `direction`")); }
    } while(0);
    do { // convert the 'STEPLocal_Origin' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::STEP::STEPCartesian_Transformation_Operator,4>::aux_is_derived[2]=true; break; }
        try { GenericConvert( in->LocalOrigin, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to STEPCartesian_Transformation_Operator to be a `cartesian_point`")); }
    } while(0);
    do { // convert the 'STEPScale' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::STEP::STEPCartesian_Transformation_Operator,4>::aux_is_derived[3]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->Scale, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to STEPCartesian_Transformation_Operator to be a `REAL`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPCartesian_Transformation_Operator_2d>(const DB& db, const LIST& params, STEPCartesian_Transformation_Operator_2d* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPCartesian_Transformation_Operator*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPCartesian_Transformation_Operator_3d>(const DB& db, const LIST& params, STEPCartesian_Transformation_Operator_3d* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPCartesian_Transformation_Operator*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSymbol_Representation>(const DB& db, const LIST& params, STEPSymbol_Representation* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPGeneric_Character_Glyph_Symbol>(const DB& db, const LIST& params, STEPGeneric_Character_Glyph_Symbol* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSymbol_Representation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPCharacter_Glyph_Symbol>(const DB& db, const LIST& params, STEPCharacter_Glyph_Symbol* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeneric_Character_Glyph_Symbol*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPCharacter_Glyph_Symbol_Outline>(const DB& db, const LIST& params, STEPCharacter_Glyph_Symbol_Outline* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPCharacter_Glyph_Symbol*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPCharacter_Glyph_Symbol_Stroke>(const DB& db, const LIST& params, STEPCharacter_Glyph_Symbol_Stroke* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPCharacter_Glyph_Symbol*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPConic>(const DB& db, const LIST& params, STEPConic* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPCurve*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to STEPConic"); }    do { // convert the 'STEPPosition' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::STEP::STEPConic,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->Position, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to STEPConic to be a `axis2_placement`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPCircle>(const DB& db, const LIST& params, STEPCircle* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPConic*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to STEPCircle"); }    do { // convert the 'STEPRadius' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Radius, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to STEPCircle to be a `positive_length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPConnected_Face_Set>(const DB& db, const LIST& params, STEPConnected_Face_Set* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPTopological_Representation_Item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to STEPConnected_Face_Set"); }    do { // convert the 'STEPCfs_Faces' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::STEP::STEPConnected_Face_Set,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->CfsFaces, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to STEPConnected_Face_Set to be a `SET [1:?] OF face`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPClosed_Shell>(const DB& db, const LIST& params, STEPClosed_Shell* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPConnected_Face_Set*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPColour_Specification>(const DB& db, const LIST& params, STEPColour_Specification* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPColour*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to STEPColour_Specification"); }    do { // convert the 'STEPName' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::STEP::STEPColour_Specification,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->Name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to STEPColour_Specification to be a `label`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPColour_Rgb>(const DB& db, const LIST& params, STEPColour_Rgb* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPColour_Specification*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to STEPColour_Rgb"); }    do { // convert the 'STEPRed' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Red, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to STEPColour_Rgb to be a `REAL`")); }
    } while(0);
    do { // convert the 'STEPGreen' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Green, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to STEPColour_Rgb to be a `REAL`")); }
    } while(0);
    do { // convert the 'STEPBlue' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Blue, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to STEPColour_Rgb to be a `REAL`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPComplex_Clause>(const DB& db, const LIST& params, STEPComplex_Clause* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPCompound_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPComplex_Conjunctive_Clause>(const DB& db, const LIST& params, STEPComplex_Conjunctive_Clause* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPComplex_Clause*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPComplex_Disjunctive_Clause>(const DB& db, const LIST& params, STEPComplex_Disjunctive_Clause* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPComplex_Clause*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPModified_Solid>(const DB& db, const LIST& params, STEPModified_Solid* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSolid_Model*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPShelled_Solid>(const DB& db, const LIST& params, STEPShelled_Solid* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPModified_Solid*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPComplex_Shelled_Solid>(const DB& db, const LIST& params, STEPComplex_Shelled_Solid* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPShelled_Solid*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPComposite_Curve_Segment>(const DB& db, const LIST& params, STEPComposite_Curve_Segment* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPFounded_Item*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to STEPComposite_Curve_Segment"); }    do { // convert the 'STEPTransition' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::STEP::STEPComposite_Curve_Segment,3>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->Transition, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to STEPComposite_Curve_Segment to be a `transition_code`")); }
    } while(0);
    do { // convert the 'STEPSame_Sense' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::STEP::STEPComposite_Curve_Segment,3>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->SameSense, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to STEPComposite_Curve_Segment to be a `BOOLEAN`")); }
    } while(0);
    do { // convert the 'STEPParent_Curve' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::STEP::STEPComposite_Curve_Segment,3>::aux_is_derived[2]=true; break; }
        try { GenericConvert( in->ParentCurve, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to STEPComposite_Curve_Segment to be a `curve`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPComposite_Sheet_Representation>(const DB& db, const LIST& params, STEPComposite_Sheet_Representation* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPShape_Representation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPComposite_Text>(const DB& db, const LIST& params, STEPComposite_Text* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPComposite_Text_With_Associated_Curves>(const DB& db, const LIST& params, STEPComposite_Text_With_Associated_Curves* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPComposite_Text*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPComposite_Text_With_Blanking_Box>(const DB& db, const LIST& params, STEPComposite_Text_With_Blanking_Box* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPComposite_Text*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPComposite_Text_With_Delineation>(const DB& db, const LIST& params, STEPComposite_Text_With_Delineation* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPComposite_Text*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPComposite_Text_With_Extent>(const DB& db, const LIST& params, STEPComposite_Text_With_Extent* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPComposite_Text*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPCompound_Shape_Representation>(const DB& db, const LIST& params, STEPCompound_Shape_Representation* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPShape_Representation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPConical_Stepped_Hole_Transition>(const DB& db, const LIST& params, STEPConical_Stepped_Hole_Transition* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPElementary_Surface>(const DB& db, const LIST& params, STEPElementary_Surface* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSurface*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to STEPElementary_Surface"); }    do { // convert the 'STEPPosition' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::STEP::STEPElementary_Surface,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->Position, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to STEPElementary_Surface to be a `axis2_placement_3d`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPConical_Surface>(const DB& db, const LIST& params, STEPConical_Surface* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPElementary_Surface*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPConnected_Edge_Set>(const DB& db, const LIST& params, STEPConnected_Edge_Set* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPTopological_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPConnected_Face_Sub_Set>(const DB& db, const LIST& params, STEPConnected_Face_Sub_Set* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPConnected_Face_Set*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPConstructive_Geometry_Representation>(const DB& db, const LIST& params, STEPConstructive_Geometry_Representation* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPContact_Ratio_Representation>(const DB& db, const LIST& params, STEPContact_Ratio_Representation* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPOver_Riding_Styled_Item>(const DB& db, const LIST& params, STEPOver_Riding_Styled_Item* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPStyled_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPContext_Dependent_Over_Riding_Styled_Item>(const DB& db, const LIST& params, STEPContext_Dependent_Over_Riding_Styled_Item* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPOver_Riding_Styled_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPContext_Dependent_Unit>(const DB& db, const LIST& params, STEPContext_Dependent_Unit* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPNamed_Unit*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPConversion_Based_Unit>(const DB& db, const LIST& params, STEPConversion_Based_Unit* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPNamed_Unit*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to STEPConversion_Based_Unit"); }    do { // convert the 'STEPName' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::STEP::STEPConversion_Based_Unit,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->Name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to STEPConversion_Based_Unit to be a `label`")); }
    } while(0);
    do { // convert the 'STEPConversion_Factor' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::STEP::STEPConversion_Based_Unit,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->ConversionFactor, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to STEPConversion_Based_Unit to be a `measure_with_unit`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPCsg_Shape_Representation>(const DB& db, const LIST& params, STEPCsg_Shape_Representation* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPShape_Representation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPCsg_Solid>(const DB& db, const LIST& params, STEPCsg_Solid* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSolid_Model*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPCurrency>(const DB& db, const LIST& params, STEPCurrency* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPContext_Dependent_Unit*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPCurve_Bounded_Surface>(const DB& db, const LIST& params, STEPCurve_Bounded_Surface* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPBounded_Surface*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPCurve_Dimension>(const DB& db, const LIST& params, STEPCurve_Dimension* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPDimension_Curve_Directed_Callout*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPCurve_Replica>(const DB& db, const LIST& params, STEPCurve_Replica* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPCurve*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPCurve_Swept_Solid_Shape_Representation>(const DB& db, const LIST& params, STEPCurve_Swept_Solid_Shape_Representation* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPShape_Representation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPCylindrical_Surface>(const DB& db, const LIST& params, STEPCylindrical_Surface* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPElementary_Surface*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPDate_Representation_Item>(const DB& db, const LIST& params, STEPDate_Representation_Item* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPDate_Time_Representation_Item>(const DB& db, const LIST& params, STEPDate_Time_Representation_Item* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPDatum_Feature_Callout>(const DB& db, const LIST& params, STEPDatum_Feature_Callout* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPDraughting_Callout*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPDatum_Target_Callout>(const DB& db, const LIST& params, STEPDatum_Target_Callout* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPDraughting_Callout*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPDefault_Tolerance_Table>(const DB& db, const LIST& params, STEPDefault_Tolerance_Table* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPDefault_Tolerance_Table_Cell>(const DB& db, const LIST& params, STEPDefault_Tolerance_Table_Cell* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPCompound_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPDefined_Symbol>(const DB& db, const LIST& params, STEPDefined_Symbol* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPDefinitional_Representation>(const DB& db, const LIST& params, STEPDefinitional_Representation* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPDegenerate_Pcurve>(const DB& db, const LIST& params, STEPDegenerate_Pcurve* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPPoint*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPToroidal_Surface>(const DB& db, const LIST& params, STEPToroidal_Surface* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPElementary_Surface*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPDegenerate_Toroidal_Surface>(const DB& db, const LIST& params, STEPDegenerate_Toroidal_Surface* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPToroidal_Surface*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPDescriptive_Representation_Item>(const DB& db, const LIST& params, STEPDescriptive_Representation_Item* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPDiameter_Dimension>(const DB& db, const LIST& params, STEPDiameter_Dimension* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPDimension_Curve_Directed_Callout*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPDimension_Callout>(const DB& db, const LIST& params, STEPDimension_Callout* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPDraughting_Callout*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPDimension_Curve>(const DB& db, const LIST& params, STEPDimension_Curve* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPAnnotation_Curve_Occurrence*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPTerminator_Symbol>(const DB& db, const LIST& params, STEPTerminator_Symbol* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPAnnotation_Symbol_Occurrence*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPDimension_Curve_Terminator>(const DB& db, const LIST& params, STEPDimension_Curve_Terminator* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPTerminator_Symbol*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPText_Literal>(const DB& db, const LIST& params, STEPText_Literal* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPDimension_Text_Associativity>(const DB& db, const LIST& params, STEPDimension_Text_Associativity* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPText_Literal*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPDirection>(const DB& db, const LIST& params, STEPDirection* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Representation_Item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to STEPDirection"); }    do { // convert the 'STEPDirection_Ratios' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->DirectionRatios, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to STEPDirection to be a `LIST [2:3] OF REAL`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPDouble_Offset_Shelled_Solid>(const DB& db, const LIST& params, STEPDouble_Offset_Shelled_Solid* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPShelled_Solid*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPDraughting_Annotation_Occurrence>(const DB& db, const LIST& params, STEPDraughting_Annotation_Occurrence* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPAnnotation_Occurrence*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPDraughting_Elements>(const DB& db, const LIST& params, STEPDraughting_Elements* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPDraughting_Callout*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPDraughting_Model>(const DB& db, const LIST& params, STEPDraughting_Model* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPPre_Defined_Item>(const DB& db, const LIST& params, STEPPre_Defined_Item* in)
{
	size_t base = 0;
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to STEPPre_Defined_Item"); }    do { // convert the 'STEPName' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::STEP::STEPPre_Defined_Item,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->Name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to STEPPre_Defined_Item to be a `label`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPDraughting_Subfigure_Representation>(const DB& db, const LIST& params, STEPDraughting_Subfigure_Representation* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSymbol_Representation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPDraughting_Symbol_Representation>(const DB& db, const LIST& params, STEPDraughting_Symbol_Representation* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSymbol_Representation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPText_Literal_With_Delineation>(const DB& db, const LIST& params, STEPText_Literal_With_Delineation* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPText_Literal*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPDraughting_Text_Literal_With_Delineation>(const DB& db, const LIST& params, STEPDraughting_Text_Literal_With_Delineation* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPText_Literal_With_Delineation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPPresentation_Representation>(const DB& db, const LIST& params, STEPPresentation_Representation* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPPresentation_Area>(const DB& db, const LIST& params, STEPPresentation_Area* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPPresentation_Representation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPDrawing_Sheet_Revision>(const DB& db, const LIST& params, STEPDrawing_Sheet_Revision* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPPresentation_Area*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPEdge>(const DB& db, const LIST& params, STEPEdge* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPTopological_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPEdge_Based_Wireframe_Model>(const DB& db, const LIST& params, STEPEdge_Based_Wireframe_Model* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPEdge_Based_Wireframe_Shape_Representation>(const DB& db, const LIST& params, STEPEdge_Based_Wireframe_Shape_Representation* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPShape_Representation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPEdge_Blended_Solid>(const DB& db, const LIST& params, STEPEdge_Blended_Solid* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPModified_Solid*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPEdge_Curve>(const DB& db, const LIST& params, STEPEdge_Curve* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPEdge*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPPath>(const DB& db, const LIST& params, STEPPath* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPTopological_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPLoop>(const DB& db, const LIST& params, STEPLoop* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPTopological_Representation_Item*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to STEPLoop"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPEdge_Loop>(const DB& db, const LIST& params, STEPEdge_Loop* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPLoop*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPElectric_Current_Unit>(const DB& db, const LIST& params, STEPElectric_Current_Unit* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPNamed_Unit*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPElementary_Brep_Shape_Representation>(const DB& db, const LIST& params, STEPElementary_Brep_Shape_Representation* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPShape_Representation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPEllipse>(const DB& db, const LIST& params, STEPEllipse* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPConic*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to STEPEllipse"); }    do { // convert the 'STEPSemi_Axis_1' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->SemiAxis1, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to STEPEllipse to be a `positive_length_measure`")); }
    } while(0);
    do { // convert the 'STEPSemi_Axis_2' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->SemiAxis2, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to STEPEllipse to be a `positive_length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPEnum_Reference_Prefix>(const DB& db, const LIST& params, STEPEnum_Reference_Prefix* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPDescriptive_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPEvaluated_Characteristic>(const DB& db, const LIST& params, STEPEvaluated_Characteristic* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPEvaluated_Degenerate_Pcurve>(const DB& db, const LIST& params, STEPEvaluated_Degenerate_Pcurve* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPDegenerate_Pcurve*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPExpression_Conversion_Based_Unit>(const DB& db, const LIST& params, STEPExpression_Conversion_Based_Unit* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPContext_Dependent_Unit*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPExternally_Defined_Context_Dependent_Unit>(const DB& db, const LIST& params, STEPExternally_Defined_Context_Dependent_Unit* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPContext_Dependent_Unit*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPExternally_Defined_Conversion_Based_Unit>(const DB& db, const LIST& params, STEPExternally_Defined_Conversion_Based_Unit* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPConversion_Based_Unit*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPExternally_Defined_Currency>(const DB& db, const LIST& params, STEPExternally_Defined_Currency* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPCurrency*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPExternally_Defined_Hatch_Style>(const DB& db, const LIST& params, STEPExternally_Defined_Hatch_Style* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPExternally_Defined_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPPicture_Representation_Item>(const DB& db, const LIST& params, STEPPicture_Representation_Item* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPBytes_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPExternally_Defined_Picture_Representation_Item>(const DB& db, const LIST& params, STEPExternally_Defined_Picture_Representation_Item* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPPicture_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPExternally_Defined_Representation_Item>(const DB& db, const LIST& params, STEPExternally_Defined_Representation_Item* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPExternally_Defined_String>(const DB& db, const LIST& params, STEPExternally_Defined_String* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPExternally_Defined_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPExternally_Defined_Tile_Style>(const DB& db, const LIST& params, STEPExternally_Defined_Tile_Style* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPExternally_Defined_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSwept_Area_Solid>(const DB& db, const LIST& params, STEPSwept_Area_Solid* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSolid_Model*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to STEPSwept_Area_Solid"); }    do { // convert the 'STEPSwept_Area' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::STEP::STEPSwept_Area_Solid,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->SweptArea, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to STEPSwept_Area_Solid to be a `curve_bounded_surface`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPExtruded_Area_Solid>(const DB& db, const LIST& params, STEPExtruded_Area_Solid* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSwept_Area_Solid*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to STEPExtruded_Area_Solid"); }    do { // convert the 'STEPExtruded_Direction' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->ExtrudedDirection, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to STEPExtruded_Area_Solid to be a `direction`")); }
    } while(0);
    do { // convert the 'STEPDepth' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Depth, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to STEPExtruded_Area_Solid to be a `positive_length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSwept_Face_Solid>(const DB& db, const LIST& params, STEPSwept_Face_Solid* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSolid_Model*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPExtruded_Face_Solid>(const DB& db, const LIST& params, STEPExtruded_Face_Solid* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSwept_Face_Solid*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPExtruded_Face_Solid_With_Trim_Conditions>(const DB& db, const LIST& params, STEPExtruded_Face_Solid_With_Trim_Conditions* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPExtruded_Face_Solid*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPExtruded_Face_Solid_With_Draft_Angle>(const DB& db, const LIST& params, STEPExtruded_Face_Solid_With_Draft_Angle* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPExtruded_Face_Solid_With_Trim_Conditions*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPExtruded_Face_Solid_With_Multiple_Draft_Angles>(const DB& db, const LIST& params, STEPExtruded_Face_Solid_With_Multiple_Draft_Angles* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPExtruded_Face_Solid_With_Trim_Conditions*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPFace_Based_Surface_Model>(const DB& db, const LIST& params, STEPFace_Based_Surface_Model* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Representation_Item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to STEPFace_Based_Surface_Model"); }    do { // convert the 'STEPFbsm_Faces' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->FbsmFaces, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to STEPFace_Based_Surface_Model to be a `SET [1:?] OF connected_face_set`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPFace_Bound>(const DB& db, const LIST& params, STEPFace_Bound* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPTopological_Representation_Item*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to STEPFace_Bound"); }    do { // convert the 'STEPBound' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::STEP::STEPFace_Bound,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->Bound, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to STEPFace_Bound to be a `loop`")); }
    } while(0);
    do { // convert the 'STEPOrientation' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::STEP::STEPFace_Bound,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->Orientation, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to STEPFace_Bound to be a `BOOLEAN`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPFace_Outer_Bound>(const DB& db, const LIST& params, STEPFace_Outer_Bound* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPFace_Bound*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to STEPFace_Outer_Bound"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPFaceted_Brep>(const DB& db, const LIST& params, STEPFaceted_Brep* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPManifold_Solid_Brep*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPFaceted_Brep_Shape_Representation>(const DB& db, const LIST& params, STEPFaceted_Brep_Shape_Representation* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPShape_Representation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPFill_Area_Style>(const DB& db, const LIST& params, STEPFill_Area_Style* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPFounded_Item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to STEPFill_Area_Style"); }    do { // convert the 'STEPName' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to STEPFill_Area_Style to be a `label`")); }
    } while(0);
    do { // convert the 'STEPFill_Styles' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->FillStyles, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to STEPFill_Area_Style to be a `SET [1:?] OF fill_style_select`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPFill_Area_Style_Colour>(const DB& db, const LIST& params, STEPFill_Area_Style_Colour* in)
{
	size_t base = 0;
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to STEPFill_Area_Style_Colour"); }    do { // convert the 'STEPName' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to STEPFill_Area_Style_Colour to be a `label`")); }
    } while(0);
    do { // convert the 'STEPFill_Colour' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->FillColour, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to STEPFill_Area_Style_Colour to be a `colour`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPFill_Area_Style_Hatching>(const DB& db, const LIST& params, STEPFill_Area_Style_Hatching* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPFill_Area_Style_Tile_Coloured_Region>(const DB& db, const LIST& params, STEPFill_Area_Style_Tile_Coloured_Region* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPFill_Area_Style_Tile_Curve_With_Style>(const DB& db, const LIST& params, STEPFill_Area_Style_Tile_Curve_With_Style* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPFill_Area_Style_Tile_Symbol_With_Style>(const DB& db, const LIST& params, STEPFill_Area_Style_Tile_Symbol_With_Style* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPFill_Area_Style_Tiles>(const DB& db, const LIST& params, STEPFill_Area_Style_Tiles* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPForward_Chaining_Rule_Premise>(const DB& db, const LIST& params, STEPForward_Chaining_Rule_Premise* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPProperty_Definition*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPFunc>(const DB& db, const LIST& params, STEPFunc* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPCompound_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPGeometric_Set>(const DB& db, const LIST& params, STEPGeometric_Set* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPGeometric_Curve_Set>(const DB& db, const LIST& params, STEPGeometric_Curve_Set* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Set*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPGeometric_Model_Element_Relationship>(const DB& db, const LIST& params, STEPGeometric_Model_Element_Relationship* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPRepresentation_Context>(const DB& db, const LIST& params, STEPRepresentation_Context* in)
{
	size_t base = 0;
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to STEPRepresentation_Context"); }    do { // convert the 'STEPContext_Identifier' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::STEP::STEPRepresentation_Context,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->ContextIdentifier, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to STEPRepresentation_Context to be a `identifier`")); }
    } while(0);
    do { // convert the 'STEPContext_Type' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::STEP::STEPRepresentation_Context,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->ContextType, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to STEPRepresentation_Context to be a `text`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPGeometric_Representation_Context>(const DB& db, const LIST& params, STEPGeometric_Representation_Context* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation_Context*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to STEPGeometric_Representation_Context"); }    do { // convert the 'STEPCoordinate_Space_Dimension' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->CoordinateSpaceDimension, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to STEPGeometric_Representation_Context to be a `dimension_count`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPGeometrical_Tolerance_Callout>(const DB& db, const LIST& params, STEPGeometrical_Tolerance_Callout* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPDraughting_Callout*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPGeometrically_Bounded_2d_Wireframe_Representation>(const DB& db, const LIST& params, STEPGeometrically_Bounded_2d_Wireframe_Representation* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPShape_Representation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPGeometrically_Bounded_Surface_Shape_Representation>(const DB& db, const LIST& params, STEPGeometrically_Bounded_Surface_Shape_Representation* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPShape_Representation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPGeometrically_Bounded_Wireframe_Shape_Representation>(const DB& db, const LIST& params, STEPGeometrically_Bounded_Wireframe_Shape_Representation* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPShape_Representation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPGlobal_Uncertainty_Assigned_Context>(const DB& db, const LIST& params, STEPGlobal_Uncertainty_Assigned_Context* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation_Context*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPGlobal_Unit_Assigned_Context>(const DB& db, const LIST& params, STEPGlobal_Unit_Assigned_Context* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation_Context*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPGround_Fact>(const DB& db, const LIST& params, STEPGround_Fact* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPAtomic_Formula*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPHardness_Representation>(const DB& db, const LIST& params, STEPHardness_Representation* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPHidden_Element_Over_Riding_Styled_Item>(const DB& db, const LIST& params, STEPHidden_Element_Over_Riding_Styled_Item* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPContext_Dependent_Over_Riding_Styled_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPHyperbola>(const DB& db, const LIST& params, STEPHyperbola* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPConic*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPIncluded_Text_Block>(const DB& db, const LIST& params, STEPIncluded_Text_Block* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPMapped_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPUser_Selected_Elements>(const DB& db, const LIST& params, STEPUser_Selected_Elements* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPIndirectly_Selected_Elements>(const DB& db, const LIST& params, STEPIndirectly_Selected_Elements* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPUser_Selected_Elements*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPUser_Selected_Shape_Elements>(const DB& db, const LIST& params, STEPUser_Selected_Shape_Elements* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPUser_Selected_Elements*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPIndirectly_Selected_Shape_Elements>(const DB& db, const LIST& params, STEPIndirectly_Selected_Shape_Elements* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPIndirectly_Selected_Elements*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPInteger_Representation_Item>(const DB& db, const LIST& params, STEPInteger_Representation_Item* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPIntersection_Curve>(const DB& db, const LIST& params, STEPIntersection_Curve* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSurface_Curve*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPIso4217_Currency>(const DB& db, const LIST& params, STEPIso4217_Currency* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPCurrency*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPLeader_Curve>(const DB& db, const LIST& params, STEPLeader_Curve* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPAnnotation_Curve_Occurrence*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPLeader_Directed_Callout>(const DB& db, const LIST& params, STEPLeader_Directed_Callout* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPDraughting_Callout*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPLeader_Directed_Dimension>(const DB& db, const LIST& params, STEPLeader_Directed_Dimension* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPLeader_Directed_Callout*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPLeader_Terminator>(const DB& db, const LIST& params, STEPLeader_Terminator* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPTerminator_Symbol*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPLength_Unit>(const DB& db, const LIST& params, STEPLength_Unit* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPNamed_Unit*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPLight_Source>(const DB& db, const LIST& params, STEPLight_Source* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPLight_Source_Ambient>(const DB& db, const LIST& params, STEPLight_Source_Ambient* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPLight_Source*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPLight_Source_Directional>(const DB& db, const LIST& params, STEPLight_Source_Directional* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPLight_Source*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPLight_Source_Positional>(const DB& db, const LIST& params, STEPLight_Source_Positional* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPLight_Source*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPLight_Source_Spot>(const DB& db, const LIST& params, STEPLight_Source_Spot* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPLight_Source*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPLine>(const DB& db, const LIST& params, STEPLine* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPCurve*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to STEPLine"); }    do { // convert the 'STEPPnt' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Pnt, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to STEPLine to be a `cartesian_point`")); }
    } while(0);
    do { // convert the 'STEPDir' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Dir, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to STEPLine to be a `vector`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPLinear_Dimension>(const DB& db, const LIST& params, STEPLinear_Dimension* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPDimension_Curve_Directed_Callout*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSimple_Clause>(const DB& db, const LIST& params, STEPSimple_Clause* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPCompound_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPLiteral_Conjunction>(const DB& db, const LIST& params, STEPLiteral_Conjunction* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSimple_Clause*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPLiteral_Disjunction>(const DB& db, const LIST& params, STEPLiteral_Disjunction* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSimple_Clause*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPLogical_Representation_Item>(const DB& db, const LIST& params, STEPLogical_Representation_Item* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPLuminous_Flux_Unit>(const DB& db, const LIST& params, STEPLuminous_Flux_Unit* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPNamed_Unit*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPLuminous_Intensity_Unit>(const DB& db, const LIST& params, STEPLuminous_Intensity_Unit* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPNamed_Unit*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPManifold_Subsurface_Shape_Representation>(const DB& db, const LIST& params, STEPManifold_Subsurface_Shape_Representation* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPShape_Representation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPManifold_Surface_Shape_Representation>(const DB& db, const LIST& params, STEPManifold_Surface_Shape_Representation* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPShape_Representation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPMass_Unit>(const DB& db, const LIST& params, STEPMass_Unit* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPNamed_Unit*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPMeasure_Representation_Item>(const DB& db, const LIST& params, STEPMeasure_Representation_Item* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPMechanical_Design_Geometric_Presentation_Area>(const DB& db, const LIST& params, STEPMechanical_Design_Geometric_Presentation_Area* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPPresentation_Area*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPMechanical_Design_Geometric_Presentation_Representation>(const DB& db, const LIST& params, STEPMechanical_Design_Geometric_Presentation_Representation* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPMechanical_Design_Presentation_Representation_With_Draughting>(const DB& db, const LIST& params, STEPMechanical_Design_Presentation_Representation_With_Draughting* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPMechanical_Design_Shaded_Presentation_Area>(const DB& db, const LIST& params, STEPMechanical_Design_Shaded_Presentation_Area* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPPresentation_Area*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPMechanical_Design_Shaded_Presentation_Representation>(const DB& db, const LIST& params, STEPMechanical_Design_Shaded_Presentation_Representation* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPMin_And_Major_Ply_Orientation_Basis>(const DB& db, const LIST& params, STEPMin_And_Major_Ply_Orientation_Basis* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation_Item_Relationship*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPModified_Solid_With_Placed_Configuration>(const DB& db, const LIST& params, STEPModified_Solid_With_Placed_Configuration* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPModified_Solid*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPMoments_Of_Inertia_Representation>(const DB& db, const LIST& params, STEPMoments_Of_Inertia_Representation* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPNon_Manifold_Surface_Shape_Representation>(const DB& db, const LIST& params, STEPNon_Manifold_Surface_Shape_Representation* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPShape_Representation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPNull_Representation_Item>(const DB& db, const LIST& params, STEPNull_Representation_Item* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPOffset_Curve_2d>(const DB& db, const LIST& params, STEPOffset_Curve_2d* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPCurve*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPOffset_Curve_3d>(const DB& db, const LIST& params, STEPOffset_Curve_3d* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPCurve*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPOffset_Surface>(const DB& db, const LIST& params, STEPOffset_Surface* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSurface*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPOne_Direction_Repeat_Factor>(const DB& db, const LIST& params, STEPOne_Direction_Repeat_Factor* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPOpen_Shell>(const DB& db, const LIST& params, STEPOpen_Shell* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPConnected_Face_Set*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPProjection_Directed_Callout>(const DB& db, const LIST& params, STEPProjection_Directed_Callout* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPDraughting_Callout*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPOrdinate_Dimension>(const DB& db, const LIST& params, STEPOrdinate_Dimension* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPProjection_Directed_Callout*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPOriented_Closed_Shell>(const DB& db, const LIST& params, STEPOriented_Closed_Shell* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPClosed_Shell*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPOriented_Edge>(const DB& db, const LIST& params, STEPOriented_Edge* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPEdge*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPOriented_Face>(const DB& db, const LIST& params, STEPOriented_Face* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPFace*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPOriented_Open_Shell>(const DB& db, const LIST& params, STEPOriented_Open_Shell* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPOpen_Shell*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPOriented_Path>(const DB& db, const LIST& params, STEPOriented_Path* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPPath*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPOriented_Surface>(const DB& db, const LIST& params, STEPOriented_Surface* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSurface*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPOuter_Boundary_Curve>(const DB& db, const LIST& params, STEPOuter_Boundary_Curve* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPBoundary_Curve*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPParabola>(const DB& db, const LIST& params, STEPParabola* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPConic*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPParametric_Representation_Context>(const DB& db, const LIST& params, STEPParametric_Representation_Context* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation_Context*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPPresentation_View>(const DB& db, const LIST& params, STEPPresentation_View* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPPresentation_Representation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPPicture_Representation>(const DB& db, const LIST& params, STEPPicture_Representation* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPPresentation_View*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPPlanar_Extent>(const DB& db, const LIST& params, STEPPlanar_Extent* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPPlanar_Box>(const DB& db, const LIST& params, STEPPlanar_Box* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPPlanar_Extent*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPPlane>(const DB& db, const LIST& params, STEPPlane* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPElementary_Surface*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to STEPPlane"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPPlane_Angle_Unit>(const DB& db, const LIST& params, STEPPlane_Angle_Unit* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPNamed_Unit*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPPoint_And_Vector>(const DB& db, const LIST& params, STEPPoint_And_Vector* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPCompound_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPPoint_On_Curve>(const DB& db, const LIST& params, STEPPoint_On_Curve* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPPoint*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPPoint_On_Surface>(const DB& db, const LIST& params, STEPPoint_On_Surface* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPPoint*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPPoint_Path>(const DB& db, const LIST& params, STEPPoint_Path* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPCompound_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPPoint_Replica>(const DB& db, const LIST& params, STEPPoint_Replica* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPPoint*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPPoly_Loop>(const DB& db, const LIST& params, STEPPoly_Loop* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPLoop*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to STEPPoly_Loop"); }    do { // convert the 'STEPPolygon' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Polygon, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to STEPPoly_Loop to be a `LIST [3:?] OF cartesian_point`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPPolyline>(const DB& db, const LIST& params, STEPPolyline* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPBounded_Curve*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to STEPPolyline"); }    do { // convert the 'STEPPoints' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Points, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to STEPPolyline to be a `LIST [2:?] OF cartesian_point`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPPositioned_Sketch>(const DB& db, const LIST& params, STEPPositioned_Sketch* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPPre_Defined_Surface_Side_Style>(const DB& db, const LIST& params, STEPPre_Defined_Surface_Side_Style* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPPre_Defined_Item*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to STEPPre_Defined_Surface_Side_Style"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPPredefined_Picture_Representation_Item>(const DB& db, const LIST& params, STEPPredefined_Picture_Representation_Item* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPPicture_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPPresentation_Style_Assignment>(const DB& db, const LIST& params, STEPPresentation_Style_Assignment* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPFounded_Item*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to STEPPresentation_Style_Assignment"); }    do { // convert the 'STEPStyles' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::STEP::STEPPresentation_Style_Assignment,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->Styles, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to STEPPresentation_Style_Assignment to be a `SET [1:?] OF presentation_style_select`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPPresentation_Style_By_Context>(const DB& db, const LIST& params, STEPPresentation_Style_By_Context* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPPresentation_Style_Assignment*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPProcedural_Representation>(const DB& db, const LIST& params, STEPProcedural_Representation* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPProcedural_Representation_Sequence>(const DB& db, const LIST& params, STEPProcedural_Representation_Sequence* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPProcedural_Shape_Representation>(const DB& db, const LIST& params, STEPProcedural_Shape_Representation* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPProcedural_Representation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPProcedural_Shape_Representation_Sequence>(const DB& db, const LIST& params, STEPProcedural_Shape_Representation_Sequence* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPProjection_Curve>(const DB& db, const LIST& params, STEPProjection_Curve* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPAnnotation_Curve_Occurrence*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPQualified_Representation_Item>(const DB& db, const LIST& params, STEPQualified_Representation_Item* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPQuasi_Uniform_Curve>(const DB& db, const LIST& params, STEPQuasi_Uniform_Curve* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPB_Spline_Curve*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPQuasi_Uniform_Surface>(const DB& db, const LIST& params, STEPQuasi_Uniform_Surface* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPB_Spline_Surface*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPRadius_Dimension>(const DB& db, const LIST& params, STEPRadius_Dimension* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPDimension_Curve_Directed_Callout*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPRange_Characteristic>(const DB& db, const LIST& params, STEPRange_Characteristic* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPRatio_Unit>(const DB& db, const LIST& params, STEPRatio_Unit* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPNamed_Unit*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPRational_B_Spline_Curve>(const DB& db, const LIST& params, STEPRational_B_Spline_Curve* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPB_Spline_Curve*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPRational_B_Spline_Surface>(const DB& db, const LIST& params, STEPRational_B_Spline_Surface* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPB_Spline_Surface*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPRational_Representation_Item>(const DB& db, const LIST& params, STEPRational_Representation_Item* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPReal_Representation_Item>(const DB& db, const LIST& params, STEPReal_Representation_Item* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPRectangular_Composite_Surface>(const DB& db, const LIST& params, STEPRectangular_Composite_Surface* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPBounded_Surface*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPRectangular_Trimmed_Surface>(const DB& db, const LIST& params, STEPRectangular_Trimmed_Surface* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPBounded_Surface*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPRep_Item_Group>(const DB& db, const LIST& params, STEPRep_Item_Group* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGroup*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPReparametrised_Composite_Curve_Segment>(const DB& db, const LIST& params, STEPReparametrised_Composite_Curve_Segment* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPComposite_Curve_Segment*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPRevolved_Area_Solid>(const DB& db, const LIST& params, STEPRevolved_Area_Solid* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSwept_Area_Solid*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to STEPRevolved_Area_Solid"); }    do { // convert the 'STEPAxis' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Axis, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to STEPRevolved_Area_Solid to be a `axis1_placement`")); }
    } while(0);
    do { // convert the 'STEPAngle' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Angle, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to STEPRevolved_Area_Solid to be a `plane_angle_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPRevolved_Face_Solid>(const DB& db, const LIST& params, STEPRevolved_Face_Solid* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSwept_Face_Solid*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPRevolved_Face_Solid_With_Trim_Conditions>(const DB& db, const LIST& params, STEPRevolved_Face_Solid_With_Trim_Conditions* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRevolved_Face_Solid*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPRight_Angular_Wedge>(const DB& db, const LIST& params, STEPRight_Angular_Wedge* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPRight_Circular_Cone>(const DB& db, const LIST& params, STEPRight_Circular_Cone* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPRight_Circular_Cylinder>(const DB& db, const LIST& params, STEPRight_Circular_Cylinder* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPRow_Representation_Item>(const DB& db, const LIST& params, STEPRow_Representation_Item* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPCompound_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPRow_Value>(const DB& db, const LIST& params, STEPRow_Value* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPCompound_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPRow_Variable>(const DB& db, const LIST& params, STEPRow_Variable* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPAbstract_Variable*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPRule_Condition>(const DB& db, const LIST& params, STEPRule_Condition* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPAtomic_Formula*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSurface_Curve_Swept_Area_Solid>(const DB& db, const LIST& params, STEPSurface_Curve_Swept_Area_Solid* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSwept_Area_Solid*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPRuled_Surface_Swept_Area_Solid>(const DB& db, const LIST& params, STEPRuled_Surface_Swept_Area_Solid* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSurface_Curve_Swept_Area_Solid*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPScalar_Variable>(const DB& db, const LIST& params, STEPScalar_Variable* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPAbstract_Variable*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSculptured_Solid>(const DB& db, const LIST& params, STEPSculptured_Solid* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPModified_Solid*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSeam_Curve>(const DB& db, const LIST& params, STEPSeam_Curve* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSurface_Curve*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPShape_Definition_Representation>(const DB& db, const LIST& params, STEPShape_Definition_Representation* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPProperty_Definition_Representation*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to STEPShape_Definition_Representation"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPShape_Dimension_Representation>(const DB& db, const LIST& params, STEPShape_Dimension_Representation* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPShape_Representation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPShape_Representation_With_Parameters>(const DB& db, const LIST& params, STEPShape_Representation_With_Parameters* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPShape_Representation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPShell_Based_Surface_Model>(const DB& db, const LIST& params, STEPShell_Based_Surface_Model* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Representation_Item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to STEPShell_Based_Surface_Model"); }    do { // convert the 'STEPSbsm_Boundary' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->SbsmBoundary, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to STEPShell_Based_Surface_Model to be a `SET [1:?] OF shell`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPShell_Based_Wireframe_Model>(const DB& db, const LIST& params, STEPShell_Based_Wireframe_Model* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPShell_Based_Wireframe_Shape_Representation>(const DB& db, const LIST& params, STEPShell_Based_Wireframe_Shape_Representation* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPShape_Representation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSi_Unit>(const DB& db, const LIST& params, STEPSi_Unit* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPNamed_Unit*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to STEPSi_Unit"); }    do { // convert the 'STEPPrefix' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::STEP::STEPSi_Unit,2>::aux_is_derived[0]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->Prefix, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to STEPSi_Unit to be a `si_prefix`")); }
    } while(0);
    do { // convert the 'STEPName' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::STEP::STEPSi_Unit,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->Name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to STEPSi_Unit to be a `si_unit_name`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSi_Absorbed_Dose_Unit>(const DB& db, const LIST& params, STEPSi_Absorbed_Dose_Unit* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPAbsorbed_Dose_Unit*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSi_Capacitance_Unit>(const DB& db, const LIST& params, STEPSi_Capacitance_Unit* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPCapacitance_Unit*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSi_Conductance_Unit>(const DB& db, const LIST& params, STEPSi_Conductance_Unit* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPConductance_Unit*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSi_Dose_Equivalent_Unit>(const DB& db, const LIST& params, STEPSi_Dose_Equivalent_Unit* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPDose_Equivalent_Unit*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSi_Electric_Charge_Unit>(const DB& db, const LIST& params, STEPSi_Electric_Charge_Unit* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPElectric_Charge_Unit*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSi_Electric_Potential_Unit>(const DB& db, const LIST& params, STEPSi_Electric_Potential_Unit* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPElectric_Potential_Unit*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSi_Energy_Unit>(const DB& db, const LIST& params, STEPSi_Energy_Unit* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPEnergy_Unit*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSi_Force_Unit>(const DB& db, const LIST& params, STEPSi_Force_Unit* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPForce_Unit*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSi_Frequency_Unit>(const DB& db, const LIST& params, STEPSi_Frequency_Unit* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPFrequency_Unit*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSi_Illuminance_Unit>(const DB& db, const LIST& params, STEPSi_Illuminance_Unit* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPIlluminance_Unit*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSi_Inductance_Unit>(const DB& db, const LIST& params, STEPSi_Inductance_Unit* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPInductance_Unit*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSi_Magnetic_Flux_Density_Unit>(const DB& db, const LIST& params, STEPSi_Magnetic_Flux_Density_Unit* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPMagnetic_Flux_Density_Unit*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSi_Magnetic_Flux_Unit>(const DB& db, const LIST& params, STEPSi_Magnetic_Flux_Unit* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPMagnetic_Flux_Unit*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSi_Power_Unit>(const DB& db, const LIST& params, STEPSi_Power_Unit* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPPower_Unit*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSi_Pressure_Unit>(const DB& db, const LIST& params, STEPSi_Pressure_Unit* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPPressure_Unit*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSi_Radioactivity_Unit>(const DB& db, const LIST& params, STEPSi_Radioactivity_Unit* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRadioactivity_Unit*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSi_Resistance_Unit>(const DB& db, const LIST& params, STEPSi_Resistance_Unit* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPResistance_Unit*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSolid_Angle_Unit>(const DB& db, const LIST& params, STEPSolid_Angle_Unit* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPNamed_Unit*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSolid_Replica>(const DB& db, const LIST& params, STEPSolid_Replica* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSolid_Model*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSolid_With_Chamfered_Edges>(const DB& db, const LIST& params, STEPSolid_With_Chamfered_Edges* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPEdge_Blended_Solid*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSolid_With_Angle_Based_Chamfer>(const DB& db, const LIST& params, STEPSolid_With_Angle_Based_Chamfer* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSolid_With_Chamfered_Edges*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSolid_With_Shape_Element_Pattern>(const DB& db, const LIST& params, STEPSolid_With_Shape_Element_Pattern* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPModified_Solid_With_Placed_Configuration*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSolid_With_Circular_Pattern>(const DB& db, const LIST& params, STEPSolid_With_Circular_Pattern* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSolid_With_Shape_Element_Pattern*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSolid_With_Depression>(const DB& db, const LIST& params, STEPSolid_With_Depression* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPModified_Solid_With_Placed_Configuration*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSolid_With_Pocket>(const DB& db, const LIST& params, STEPSolid_With_Pocket* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSolid_With_Depression*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSolid_With_Circular_Pocket>(const DB& db, const LIST& params, STEPSolid_With_Circular_Pocket* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSolid_With_Pocket*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSolid_With_Protrusion>(const DB& db, const LIST& params, STEPSolid_With_Protrusion* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPModified_Solid_With_Placed_Configuration*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSolid_With_Circular_Protrusion>(const DB& db, const LIST& params, STEPSolid_With_Circular_Protrusion* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSolid_With_Protrusion*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSolid_With_Hole>(const DB& db, const LIST& params, STEPSolid_With_Hole* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSolid_With_Depression*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSolid_With_Stepped_Round_Hole>(const DB& db, const LIST& params, STEPSolid_With_Stepped_Round_Hole* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSolid_With_Hole*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSolid_With_Conical_Bottom_Round_Hole>(const DB& db, const LIST& params, STEPSolid_With_Conical_Bottom_Round_Hole* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSolid_With_Stepped_Round_Hole*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSolid_With_Constant_Radius_Edge_Blend>(const DB& db, const LIST& params, STEPSolid_With_Constant_Radius_Edge_Blend* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPEdge_Blended_Solid*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSolid_With_Slot>(const DB& db, const LIST& params, STEPSolid_With_Slot* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSolid_With_Depression*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSolid_With_Curved_Slot>(const DB& db, const LIST& params, STEPSolid_With_Curved_Slot* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSolid_With_Slot*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSolid_With_Double_Offset_Chamfer>(const DB& db, const LIST& params, STEPSolid_With_Double_Offset_Chamfer* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSolid_With_Chamfered_Edges*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSolid_With_Flat_Bottom_Round_Hole>(const DB& db, const LIST& params, STEPSolid_With_Flat_Bottom_Round_Hole* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSolid_With_Stepped_Round_Hole*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSolid_With_General_Pocket>(const DB& db, const LIST& params, STEPSolid_With_General_Pocket* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSolid_With_Pocket*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSolid_With_General_Protrusion>(const DB& db, const LIST& params, STEPSolid_With_General_Protrusion* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSolid_With_Protrusion*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSolid_With_Groove>(const DB& db, const LIST& params, STEPSolid_With_Groove* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSolid_With_Depression*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSolid_With_Incomplete_Circular_Pattern>(const DB& db, const LIST& params, STEPSolid_With_Incomplete_Circular_Pattern* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSolid_With_Circular_Pattern*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSolid_With_Rectangular_Pattern>(const DB& db, const LIST& params, STEPSolid_With_Rectangular_Pattern* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSolid_With_Shape_Element_Pattern*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSolid_With_Incomplete_Rectangular_Pattern>(const DB& db, const LIST& params, STEPSolid_With_Incomplete_Rectangular_Pattern* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSolid_With_Rectangular_Pattern*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSolid_With_Rectangular_Pocket>(const DB& db, const LIST& params, STEPSolid_With_Rectangular_Pocket* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSolid_With_Pocket*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSolid_With_Rectangular_Protrusion>(const DB& db, const LIST& params, STEPSolid_With_Rectangular_Protrusion* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSolid_With_Protrusion*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSolid_With_Single_Offset_Chamfer>(const DB& db, const LIST& params, STEPSolid_With_Single_Offset_Chamfer* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSolid_With_Chamfered_Edges*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSolid_With_Spherical_Bottom_Round_Hole>(const DB& db, const LIST& params, STEPSolid_With_Spherical_Bottom_Round_Hole* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSolid_With_Stepped_Round_Hole*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSolid_With_Stepped_Round_Hole_And_Conical_Transitions>(const DB& db, const LIST& params, STEPSolid_With_Stepped_Round_Hole_And_Conical_Transitions* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSolid_With_Stepped_Round_Hole*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSolid_With_Straight_Slot>(const DB& db, const LIST& params, STEPSolid_With_Straight_Slot* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSolid_With_Slot*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSolid_With_Tee_Section_Slot>(const DB& db, const LIST& params, STEPSolid_With_Tee_Section_Slot* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSolid_With_Slot*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSolid_With_Through_Depression>(const DB& db, const LIST& params, STEPSolid_With_Through_Depression* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSolid_With_Depression*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSolid_With_Trapezoidal_Section_Slot>(const DB& db, const LIST& params, STEPSolid_With_Trapezoidal_Section_Slot* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSolid_With_Slot*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPTrack_Blended_Solid>(const DB& db, const LIST& params, STEPTrack_Blended_Solid* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPEdge_Blended_Solid*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSolid_With_Variable_Radius_Edge_Blend>(const DB& db, const LIST& params, STEPSolid_With_Variable_Radius_Edge_Blend* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPEdge_Blended_Solid*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSphere>(const DB& db, const LIST& params, STEPSphere* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSpherical_Surface>(const DB& db, const LIST& params, STEPSpherical_Surface* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPElementary_Surface*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPStructured_Dimension_Callout>(const DB& db, const LIST& params, STEPStructured_Dimension_Callout* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPDraughting_Callout*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPStructured_Text_Composition>(const DB& db, const LIST& params, STEPStructured_Text_Composition* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPCompound_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPStructured_Text_Representation>(const DB& db, const LIST& params, STEPStructured_Text_Representation* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSubedge>(const DB& db, const LIST& params, STEPSubedge* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPEdge*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSubface>(const DB& db, const LIST& params, STEPSubface* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPFace*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSurface_Condition_Callout>(const DB& db, const LIST& params, STEPSurface_Condition_Callout* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPDraughting_Callout*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSwept_Surface>(const DB& db, const LIST& params, STEPSwept_Surface* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSurface*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSurface_Of_Linear_Extrusion>(const DB& db, const LIST& params, STEPSurface_Of_Linear_Extrusion* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSwept_Surface*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSurface_Of_Revolution>(const DB& db, const LIST& params, STEPSurface_Of_Revolution* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSwept_Surface*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSurface_Replica>(const DB& db, const LIST& params, STEPSurface_Replica* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSurface*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSurface_Side_Style>(const DB& db, const LIST& params, STEPSurface_Side_Style* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPFounded_Item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to STEPSurface_Side_Style"); }    do { // convert the 'STEPName' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to STEPSurface_Side_Style to be a `label`")); }
    } while(0);
    do { // convert the 'STEPStyles' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Styles, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to STEPSurface_Side_Style to be a `SET [1:7] OF surface_style_element_select`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSurface_Style_Fill_Area>(const DB& db, const LIST& params, STEPSurface_Style_Fill_Area* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPFounded_Item*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to STEPSurface_Style_Fill_Area"); }    do { // convert the 'STEPFill_Area' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->FillArea, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to STEPSurface_Style_Fill_Area to be a `fill_area_style`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSurface_Style_Usage>(const DB& db, const LIST& params, STEPSurface_Style_Usage* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPFounded_Item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to STEPSurface_Style_Usage"); }    do { // convert the 'STEPSide' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Side, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to STEPSurface_Style_Usage to be a `surface_side`")); }
    } while(0);
    do { // convert the 'STEPStyle' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Style, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to STEPSurface_Style_Usage to be a `surface_side_style_select`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSurface_Texture_Representation>(const DB& db, const LIST& params, STEPSurface_Texture_Representation* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSurfaced_Open_Shell>(const DB& db, const LIST& params, STEPSurfaced_Open_Shell* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPOpen_Shell*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSwept_Disk_Solid>(const DB& db, const LIST& params, STEPSwept_Disk_Solid* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSolid_Model*>(in));
	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to STEPSwept_Disk_Solid"); }    do { // convert the 'STEPDirectrix' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Directrix, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to STEPSwept_Disk_Solid to be a `curve`")); }
    } while(0);
    do { // convert the 'STEPRadius' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Radius, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to STEPSwept_Disk_Solid to be a `positive_length_measure`")); }
    } while(0);
    do { // convert the 'STEPInner_Radius' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->InnerRadius, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to STEPSwept_Disk_Solid to be a `positive_length_measure`")); }
    } while(0);
    do { // convert the 'STEPStart_Param' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->StartParam, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to STEPSwept_Disk_Solid to be a `REAL`")); }
    } while(0);
    do { // convert the 'STEPEnd_Param' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->EndParam, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to STEPSwept_Disk_Solid to be a `REAL`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSymbol>(const DB& db, const LIST& params, STEPSymbol* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSymbol_Representation_Map>(const DB& db, const LIST& params, STEPSymbol_Representation_Map* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation_Map*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPSymbol_Target>(const DB& db, const LIST& params, STEPSymbol_Target* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPTable_Representation_Item>(const DB& db, const LIST& params, STEPTable_Representation_Item* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPCompound_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPTactile_Appearance_Representation>(const DB& db, const LIST& params, STEPTactile_Appearance_Representation* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPTagged_Text_Format>(const DB& db, const LIST& params, STEPTagged_Text_Format* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation_Context*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPTagged_Text_Item>(const DB& db, const LIST& params, STEPTagged_Text_Item* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPDescriptive_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPText_Literal_With_Associated_Curves>(const DB& db, const LIST& params, STEPText_Literal_With_Associated_Curves* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPText_Literal*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPText_Literal_With_Blanking_Box>(const DB& db, const LIST& params, STEPText_Literal_With_Blanking_Box* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPText_Literal*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPText_Literal_With_Extent>(const DB& db, const LIST& params, STEPText_Literal_With_Extent* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPText_Literal*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPText_String_Representation>(const DB& db, const LIST& params, STEPText_String_Representation* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPThermodynamic_Temperature_Unit>(const DB& db, const LIST& params, STEPThermodynamic_Temperature_Unit* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPNamed_Unit*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPThickened_Face_Solid>(const DB& db, const LIST& params, STEPThickened_Face_Solid* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPSolid_Model*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPTime_Unit>(const DB& db, const LIST& params, STEPTime_Unit* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPNamed_Unit*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPTorus>(const DB& db, const LIST& params, STEPTorus* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPTrack_Blended_Solid_With_End_Conditions>(const DB& db, const LIST& params, STEPTrack_Blended_Solid_With_End_Conditions* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPTrack_Blended_Solid*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPTrimmed_Curve>(const DB& db, const LIST& params, STEPTrimmed_Curve* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPBounded_Curve*>(in));
	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to STEPTrimmed_Curve"); }    do { // convert the 'STEPBasis_Curve' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->BasisCurve, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to STEPTrimmed_Curve to be a `curve`")); }
    } while(0);
    do { // convert the 'STEPTrim_1' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Trim1, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to STEPTrimmed_Curve to be a `SET [1:2] OF trimming_select`")); }
    } while(0);
    do { // convert the 'STEPTrim_2' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Trim2, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to STEPTrimmed_Curve to be a `SET [1:2] OF trimming_select`")); }
    } while(0);
    do { // convert the 'STEPSense_Agreement' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->SenseAgreement, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to STEPTrimmed_Curve to be a `BOOLEAN`")); }
    } while(0);
    do { // convert the 'STEPMaster_Representation' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->MasterRepresentation, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to STEPTrimmed_Curve to be a `trimming_preference`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPTwo_Direction_Repeat_Factor>(const DB& db, const LIST& params, STEPTwo_Direction_Repeat_Factor* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPOne_Direction_Repeat_Factor*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPUncertainty_Assigned_Representation>(const DB& db, const LIST& params, STEPUncertainty_Assigned_Representation* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPUniform_Curve>(const DB& db, const LIST& params, STEPUniform_Curve* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPB_Spline_Curve*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPUniform_Resource_Identifier>(const DB& db, const LIST& params, STEPUniform_Resource_Identifier* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPDescriptive_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPUniform_Surface>(const DB& db, const LIST& params, STEPUniform_Surface* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPB_Spline_Surface*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPUser_Defined_Curve_Font>(const DB& db, const LIST& params, STEPUser_Defined_Curve_Font* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPCurve_Style_Font*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPUser_Defined_Marker>(const DB& db, const LIST& params, STEPUser_Defined_Marker* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPMapped_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPUser_Defined_Terminator_Symbol>(const DB& db, const LIST& params, STEPUser_Defined_Terminator_Symbol* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPMapped_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPValue_Range>(const DB& db, const LIST& params, STEPValue_Range* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPCompound_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPValue_Representation_Item>(const DB& db, const LIST& params, STEPValue_Representation_Item* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPVector>(const DB& db, const LIST& params, STEPVector* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPGeometric_Representation_Item*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to STEPVector"); }    do { // convert the 'STEPOrientation' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Orientation, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to STEPVector to be a `direction`")); }
    } while(0);
    do { // convert the 'STEPMagnitude' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Magnitude, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to STEPVector to be a `length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPVertex>(const DB& db, const LIST& params, STEPVertex* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPTopological_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPVertex_Loop>(const DB& db, const LIST& params, STEPVertex_Loop* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPLoop*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPVertex_Point>(const DB& db, const LIST& params, STEPVertex_Point* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPVertex*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPVertex_Shell>(const DB& db, const LIST& params, STEPVertex_Shell* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPTopological_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPVisual_Appearance_Representation>(const DB& db, const LIST& params, STEPVisual_Appearance_Representation* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPRepresentation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<STEPWire_Shell>(const DB& db, const LIST& params, STEPWire_Shell* in)
{
	size_t base = GenericFill(db,params,static_cast<STEPTopological_Representation_Item*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
	return base;
}

} // ! STEP
} // ! Assimp

#endif
